\hypertarget{mytools_8cpp}{}\doxysection{Referencia del Archivo src/mytools.cpp}
\label{mytools_8cpp}\index{src/mytools.cpp@{src/mytools.cpp}}


Herramientas definidas para la práctica.  


{\ttfamily \#include \char`\"{}../tools/mytools.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}../tools/eigen-\/3.\+4.\+0/\+Eigen/\+Dense\char`\"{}}\newline
{\ttfamily \#include \char`\"{}../tools/random.\+hpp\char`\"{}}\newline
{\ttfamily \#include $<$fstream$>$}\newline
{\ttfamily \#include $<$math.\+h$>$}\newline
{\ttfamily \#include $<$iostream$>$}\newline
\doxysubsection*{typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{mytools_8cpp_a180f0653ebd0d5cdf633574b8c8512d3}\label{mytools_8cpp_a180f0653ebd0d5cdf633574b8c8512d3}} 
using {\bfseries Random} = effolkronium\+::random\+\_\+static
\end{DoxyCompactItemize}
\doxysubsection*{Funciones}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{mytools_8cpp_ad81243b382bfc2358283ab0091c972c3}{fill\+Range}} (vector$<$ int $>$ \&to\+Fill, unsigned int upperlimit)
\begin{DoxyCompactList}\small\item\em fill\+Range rellena un vector de valores desde 0 hasta upperlimit; \end{DoxyCompactList}\item 
double \mbox{\hyperlink{mytools_8cpp_ad065fd64357444d7792b80876fcfa41f}{min\+Euclidean\+Distance}} (Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data, Eigen\+::\+Matrix\+Xd\+::\+Index \&max\+Row)
\begin{DoxyCompactList}\small\item\em min\+Euclidean\+Distance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila \char`\"{}fixed\char`\"{} NO contenida en data. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{mytools_8cpp_a279ce1dc36aa76d8fe48671866b53dfa}{min\+Euclidean\+Distance}} (Eigen\+::\+Row\+Vector\+Xd weights, Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data, Eigen\+::\+Matrix\+Xd\+::\+Index \&max\+Row)
\begin{DoxyCompactList}\small\item\em min\+Euclidean\+Distance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila \char`\"{}fixed\char`\"{} NO contenida en data multiplicando las distancias por el vector de características que las pondera. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{mytools_8cpp_a4f5825bcc562c6dabe6c136863aedeca}{Manual\+Euclidean\+Distance}} (Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data, unsigned int pos, unsigned int \&max\+Row)
\begin{DoxyCompactList}\small\item\em Manual\+Euclidean\+Distance no-\/utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo manualmente. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{mytools_8cpp_ae96156c8bd9722dd93ecd1c7bd62a3a7}{Manual\+Euclidean\+Distance}} (Eigen\+::\+Row\+Vector\+Xd weights, Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data, unsigned int pos, unsigned int \&max\+Row)
\begin{DoxyCompactList}\small\item\em Manual\+Euclidean\+Distance no-\/utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características manualmente. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{mytools_8cpp_a15615cc501cd57df609a342fe8cca7c2}{Manual\+Euclidean\+Distance\+Type}} (Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data, vector$<$ char $>$ label, char type, unsigned int pos, unsigned int \&max\+Row)
\begin{DoxyCompactList}\small\item\em Manual\+Euclidean\+Distance\+Type no-\/utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo perteneciente a una clase específica manualmente. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{mytools_8cpp_a435bbaf48f4140898c13da58ffa48ee4}{Manual\+Euclidean\+Distance\+Type}} (Eigen\+::\+Row\+Vector\+Xd weights, Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data, vector$<$ char $>$ label, char type, unsigned int pos, unsigned int \&max\+Row)
\begin{DoxyCompactList}\small\item\em Manual\+Euclidean\+Distance\+Type no-\/utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características y perteneciente a una clase específica manualmente. \end{DoxyCompactList}\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{mytools_8cpp_abdfd60b2dabf33b1de7720bceaea78dc}{get\+Class}} (Eigen\+::\+Matrix\+Xd data, vector$<$ char $>$ Label, char type)
\begin{DoxyCompactList}\small\item\em get\+Class lo que nos devuelve es una matrix con los datos pertenecientes a una clase específica. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{mytools_8cpp_a18d1ea164d65b34e0971e329b23fc3f0}\label{mytools_8cpp_a18d1ea164d65b34e0971e329b23fc3f0}} 
Eigen\+::\+Matrix\+Xd {\bfseries get\+Class\+Labelled} (Eigen\+::\+Matrix\+Xd data, vector$<$ char $>$ Label, vector$<$ char $>$ \&new\+Label, char type)
\item 
void \mbox{\hyperlink{mytools_8cpp_ac7830bddd694d4aeb550f74ffc23528d}{get\+Fold}} (Eigen\+::\+Matrix\+Xd data, vector$<$ char $>$ Label, Eigen\+::\+Matrix\+Xd \&training, vector$<$ char $>$ \&TLabel, Eigen\+::\+Matrix\+Xd \&test, vector$<$ char $>$ \&Tt\+Label, unsigned int num)
\begin{DoxyCompactList}\small\item\em get\+Fold divide la matrix de datos \char`\"{}data\char`\"{} en dos matrices \char`\"{}tranning\char`\"{} y \char`\"{}test\char`\"{} con los datos pertenecientes a uno de los 5-\/folds que tenemos de desplazar un 20\% al grupo de test sobre el conjunto total \end{DoxyCompactList}\item 
void \mbox{\hyperlink{mytools_8cpp_a74e85088fcdeddd5575177adddcd564f}{get\+Foldby\+Loop}} (Eigen\+::\+Matrix\+Xd data, vector$<$ char $>$ Label, Eigen\+::\+Matrix\+Xd \&training, vector$<$ char $>$ \&TLabel, Eigen\+::\+Matrix\+Xd \&test, vector$<$ char $>$ \&Tt\+Label, unsigned int num)
\begin{DoxyCompactList}\small\item\em get\+Foldby\+Loop divide la matrix de datos \char`\"{}data\char`\"{} en dos matrices \char`\"{}tranning\char`\"{} y \char`\"{}test\char`\"{} con los datos pertenecientes a uno de los 5-\/folds que tenemos de desplazar un 20\% al grupo de test sobre el conjunto total. A diferencia de \mbox{\hyperlink{mytools_8h_a84ae2c8440383fed7b4006741e91cff3}{get\+Fold()}} intenta utilizar el \char`\"{}for-\/loop\char`\"{} de las etiquetas para asignar las filas. Sin embargo posee peor rendimiento. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{mytools_8cpp_a996e2cf1dca6d6f6b2e5004fd6c8f789}{get\+Balanced\+Fold}} (Eigen\+::\+Matrix\+Xd group1, vector$<$ char $>$ label1, Eigen\+::\+Matrix\+Xd group2, vector$<$ char $>$ label2, Eigen\+::\+Matrix\+Xd \&training, vector$<$ char $>$ \&TLabel, Eigen\+::\+Matrix\+Xd \&test, vector$<$ char $>$ \&Tt\+Label, unsigned int num, long int seed)
\item 
void \mbox{\hyperlink{mytools_8cpp_a29d852399058fecfd4506ac5173a8c2f}{shuffle\+Data}} (Matrix\+Xd \&mat, vector$<$ char $>$ \&label, long int seed)
\begin{DoxyCompactList}\small\item\em shuffle\+Data utiliza el archivo \char`\"{}random.\+hpp\char`\"{} y la librería Eigen para crear un vector de índices, al cual barajamos y luego utilizamos ese vector para intercambiar posiciones. Dónde el número que aparezca en la posición 0 es el intercambio de 0 con ese número y así. \end{DoxyCompactList}\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{mytools_8cpp_a3176dc33dc79b493d699596ece0e1ef7}{remove\+Row}} (Eigen\+::\+Matrix\+Xd matrix, unsigned int row\+To\+Remove)
\begin{DoxyCompactList}\small\item\em remove\+Row nos permite quitar una fila de una matrix de entrada (sin modificar la original) y devuelve la matrix resultante modificada. \end{DoxyCompactList}\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{mytools_8cpp_a1b897fefb12470c87ac53ec826fe52cb}{remove\+Column}} (Eigen\+::\+Matrix\+Xd matrix, unsigned int col\+To\+Remove)
\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{mytools_8cpp_aef11c31862b1e9d5623ad9611548fd14}{read\+Values}} (string filename, vector$<$ char $>$ \&label)
\begin{DoxyCompactList}\small\item\em read\+Values es la función utilizada para leer los archivos \char`\"{}.\+arrf\char`\"{} de la práctia en una Matrix de la libreria \char`\"{}\+Eigen\char`\"{} y un vector de etiquetas \char`\"{}\+Label\char`\"{}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Descripción detallada}
Herramientas definidas para la práctica. 

\begin{DoxyVersion}{Versión}
2.\+5 
\end{DoxyVersion}
\begin{DoxyDate}{Fecha}
05/04/2022 
\end{DoxyDate}
\begin{DoxyAuthor}{Autor}
Brian Sena Simons 3º\+A-\/\+A2 
\begin{DoxyCode}{0}
\DoxyCodeLine{ [...]}
\DoxyCodeLine{  RowVectorXd Weights = VectorXd::Constant(mat.cols(),1);}
\DoxyCodeLine{  min = \mbox{\hyperlink{mytools_8cpp_ad065fd64357444d7792b80876fcfa41f}{minEuclideanDistance}}(Weights,mat.row(0), mat.block(row,0,upper\_row -\/ row,mat.cols()),index);}
\DoxyCodeLine{  cout << \textcolor{stringliteral}{"{}Prueba de obtención de clase concreta"{}} << endl;}
\DoxyCodeLine{  cout << \textcolor{stringliteral}{"{}Obteniendo filas tipo g "{}} << endl;}
\DoxyCodeLine{  MatrixXd typeG = \mbox{\hyperlink{mytools_8cpp_abdfd60b2dabf33b1de7720bceaea78dc}{getClass}}(mat,label,\textcolor{charliteral}{'g'});}
\DoxyCodeLine{  cout << \textcolor{stringliteral}{"{}Filas: "{}} << typeG.rows() << \textcolor{stringliteral}{"{} columnas: "{}} << typeG.cols()  << endl;}
\DoxyCodeLine{  cout << \textcolor{stringliteral}{"{}\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#"{}} << endl;}
\DoxyCodeLine{[...]}

\end{DoxyCode}
 
\end{DoxyAuthor}


\doxysubsection{Documentación de las funciones}
\mbox{\Hypertarget{mytools_8cpp_ad81243b382bfc2358283ab0091c972c3}\label{mytools_8cpp_ad81243b382bfc2358283ab0091c972c3}} 
\index{mytools.cpp@{mytools.cpp}!fillRange@{fillRange}}
\index{fillRange@{fillRange}!mytools.cpp@{mytools.cpp}}
\doxysubsubsection{\texorpdfstring{fillRange()}{fillRange()}}
{\footnotesize\ttfamily void fill\+Range (\begin{DoxyParamCaption}\item[{vector$<$ int $>$ \&}]{to\+Fill,  }\item[{unsigned int}]{upperlimit }\end{DoxyParamCaption})}



fill\+Range rellena un vector de valores desde 0 hasta upperlimit; 

En esta función hacemos un simple \char`\"{}for-\/loop\char`\"{} hasta upperlimit dónde en cada iteración asignamos el valor \char`\"{}i\char`\"{} al vector generando una sucesión de 0-\/upperlimit. \mbox{\Hypertarget{mytools_8cpp_a996e2cf1dca6d6f6b2e5004fd6c8f789}\label{mytools_8cpp_a996e2cf1dca6d6f6b2e5004fd6c8f789}} 
\index{mytools.cpp@{mytools.cpp}!getBalancedFold@{getBalancedFold}}
\index{getBalancedFold@{getBalancedFold}!mytools.cpp@{mytools.cpp}}
\doxysubsubsection{\texorpdfstring{getBalancedFold()}{getBalancedFold()}}
{\footnotesize\ttfamily void get\+Balanced\+Fold (\begin{DoxyParamCaption}\item[{Eigen\+::\+Matrix\+Xd}]{group1,  }\item[{vector$<$ char $>$}]{label1,  }\item[{Eigen\+::\+Matrix\+Xd}]{group2,  }\item[{vector$<$ char $>$}]{label2,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{training,  }\item[{vector$<$ char $>$ \&}]{TLabel,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{test,  }\item[{vector$<$ char $>$ \&}]{Tt\+Label,  }\item[{unsigned int}]{num,  }\item[{long int}]{seed }\end{DoxyParamCaption})}

Hace lo mismo que \mbox{\hyperlink{mytools_8cpp_ac7830bddd694d4aeb550f74ffc23528d}{get\+Fold()}} pero con un equilibrado de clase de por medio; Se utiliza \mbox{\hyperlink{mytools_8cpp_abdfd60b2dabf33b1de7720bceaea78dc}{get\+Class()}} para obtener matrices correspondente a cada clase, se pasa a este método y lo para cada conjunto utiliza \mbox{\hyperlink{mytools_8cpp_ac7830bddd694d4aeb550f74ffc23528d}{get\+Fold()}} para obtener su correspondente 80/20 y luego lo añade todo secuencialmente en el conjunto de entreno y testeo que luego a final son barajados. \mbox{\Hypertarget{mytools_8cpp_abdfd60b2dabf33b1de7720bceaea78dc}\label{mytools_8cpp_abdfd60b2dabf33b1de7720bceaea78dc}} 
\index{mytools.cpp@{mytools.cpp}!getClass@{getClass}}
\index{getClass@{getClass}!mytools.cpp@{mytools.cpp}}
\doxysubsubsection{\texorpdfstring{getClass()}{getClass()}}
{\footnotesize\ttfamily Eigen\+::\+Matrix\+Xd get\+Class (\begin{DoxyParamCaption}\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{vector$<$ char $>$}]{Label,  }\item[{char}]{type }\end{DoxyParamCaption})}



get\+Class lo que nos devuelve es una matrix con los datos pertenecientes a una clase específica. 

La idea es iterar sobre el vector de etiquetas y cuando su valor coincida con el especificado por \char`\"{}type\char`\"{} introducimos en la matrix \char`\"{}res\char`\"{} la fila correspondiente para así calcular la matrix con apenas un tipo de clase. \mbox{\Hypertarget{mytools_8cpp_ac7830bddd694d4aeb550f74ffc23528d}\label{mytools_8cpp_ac7830bddd694d4aeb550f74ffc23528d}} 
\index{mytools.cpp@{mytools.cpp}!getFold@{getFold}}
\index{getFold@{getFold}!mytools.cpp@{mytools.cpp}}
\doxysubsubsection{\texorpdfstring{getFold()}{getFold()}}
{\footnotesize\ttfamily void get\+Fold (\begin{DoxyParamCaption}\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{vector$<$ char $>$}]{Label,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{training,  }\item[{vector$<$ char $>$ \&}]{TLabel,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{test,  }\item[{vector$<$ char $>$ \&}]{Tt\+Label,  }\item[{unsigned int}]{num }\end{DoxyParamCaption})}



get\+Fold divide la matrix de datos \char`\"{}data\char`\"{} en dos matrices \char`\"{}tranning\char`\"{} y \char`\"{}test\char`\"{} con los datos pertenecientes a uno de los 5-\/folds que tenemos de desplazar un 20\% al grupo de test sobre el conjunto total 

La idea es calcular el 20\% de la Matrix total y luego con ese valor ir estableciendo el \char`\"{}boundary\char`\"{} superior a copiar para la primera (o toda la parte del dataset de entreno cuando num=0, boundary = 80\%) y luego copiar lo que sigue a boundary hasta un 20\% más (boundary + size) en test y luego copiar devuelta lo que queda en tranning. Utilizamos la librería de Eigen para un mejor rendimiento. \mbox{\Hypertarget{mytools_8cpp_a74e85088fcdeddd5575177adddcd564f}\label{mytools_8cpp_a74e85088fcdeddd5575177adddcd564f}} 
\index{mytools.cpp@{mytools.cpp}!getFoldbyLoop@{getFoldbyLoop}}
\index{getFoldbyLoop@{getFoldbyLoop}!mytools.cpp@{mytools.cpp}}
\doxysubsubsection{\texorpdfstring{getFoldbyLoop()}{getFoldbyLoop()}}
{\footnotesize\ttfamily void get\+Foldby\+Loop (\begin{DoxyParamCaption}\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{vector$<$ char $>$}]{Label,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{training,  }\item[{vector$<$ char $>$ \&}]{TLabel,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{test,  }\item[{vector$<$ char $>$ \&}]{Tt\+Label,  }\item[{unsigned int}]{num }\end{DoxyParamCaption})}



get\+Foldby\+Loop divide la matrix de datos \char`\"{}data\char`\"{} en dos matrices \char`\"{}tranning\char`\"{} y \char`\"{}test\char`\"{} con los datos pertenecientes a uno de los 5-\/folds que tenemos de desplazar un 20\% al grupo de test sobre el conjunto total. A diferencia de \mbox{\hyperlink{mytools_8h_a84ae2c8440383fed7b4006741e91cff3}{get\+Fold()}} intenta utilizar el \char`\"{}for-\/loop\char`\"{} de las etiquetas para asignar las filas. Sin embargo posee peor rendimiento. 

La idea es calcular el 20\% de la Matrix total y luego con ese valor ir estableciendo el \char`\"{}boundary\char`\"{} superior a copiar para la primera (o toda la parte del dataset de entreno cuando num=0, boundary = 80\%) y luego copiar lo que sigue a boundary hasta un 20\% más (boundary + size) en test y luego copiar devuelta lo que queda en tranning. Pero en este caso no utilizamos las facilidades de la librería Eigen si no que apenas calculamos el tamaño total de las matrices a rellenar y vamos iterando a la vez que creamos las etiquetas adecuadas. \mbox{\Hypertarget{mytools_8cpp_a4f5825bcc562c6dabe6c136863aedeca}\label{mytools_8cpp_a4f5825bcc562c6dabe6c136863aedeca}} 
\index{mytools.cpp@{mytools.cpp}!ManualEuclideanDistance@{ManualEuclideanDistance}}
\index{ManualEuclideanDistance@{ManualEuclideanDistance}!mytools.cpp@{mytools.cpp}}
\doxysubsubsection{\texorpdfstring{ManualEuclideanDistance()}{ManualEuclideanDistance()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double Manual\+Euclidean\+Distance (\begin{DoxyParamCaption}\item[{Eigen\+::\+Row\+Vector\+Xd}]{fixed,  }\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{unsigned int}]{pos,  }\item[{unsigned int \&}]{max\+Row }\end{DoxyParamCaption})}



Manual\+Euclidean\+Distance no-\/utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo manualmente. 

Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada \char`\"{}pos\char`\"{}. \begin{DoxySeeAlso}{Ver también}
\mbox{\hyperlink{mytools_8cpp_ad065fd64357444d7792b80876fcfa41f}{min\+Euclidean\+Distance(\+Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data,\+Eigen\+::\+Matrix\+Xd\+::\+Index \&max\+Row)}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{mytools_8cpp_ae96156c8bd9722dd93ecd1c7bd62a3a7}\label{mytools_8cpp_ae96156c8bd9722dd93ecd1c7bd62a3a7}} 
\index{mytools.cpp@{mytools.cpp}!ManualEuclideanDistance@{ManualEuclideanDistance}}
\index{ManualEuclideanDistance@{ManualEuclideanDistance}!mytools.cpp@{mytools.cpp}}
\doxysubsubsection{\texorpdfstring{ManualEuclideanDistance()}{ManualEuclideanDistance()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double Manual\+Euclidean\+Distance (\begin{DoxyParamCaption}\item[{Eigen\+::\+Row\+Vector\+Xd}]{weights,  }\item[{Eigen\+::\+Row\+Vector\+Xd}]{fixed,  }\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{unsigned int}]{pos,  }\item[{unsigned int \&}]{max\+Row }\end{DoxyParamCaption})}



Manual\+Euclidean\+Distance no-\/utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características manualmente. 

Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen ponderado por los pesos característicos calculados y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada \char`\"{}pos\char`\"{}. \begin{DoxySeeAlso}{Ver también}
\mbox{\hyperlink{mytools_8cpp_a4f5825bcc562c6dabe6c136863aedeca}{Manual\+Euclidean\+Distance(\+Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data,unsigned int pos, unsigned int \&max\+Row)}}; 
\end{DoxySeeAlso}
\mbox{\Hypertarget{mytools_8cpp_a15615cc501cd57df609a342fe8cca7c2}\label{mytools_8cpp_a15615cc501cd57df609a342fe8cca7c2}} 
\index{mytools.cpp@{mytools.cpp}!ManualEuclideanDistanceType@{ManualEuclideanDistanceType}}
\index{ManualEuclideanDistanceType@{ManualEuclideanDistanceType}!mytools.cpp@{mytools.cpp}}
\doxysubsubsection{\texorpdfstring{ManualEuclideanDistanceType()}{ManualEuclideanDistanceType()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double Manual\+Euclidean\+Distance\+Type (\begin{DoxyParamCaption}\item[{Eigen\+::\+Row\+Vector\+Xd}]{fixed,  }\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{vector$<$ char $>$}]{label,  }\item[{char}]{type,  }\item[{unsigned int}]{pos,  }\item[{unsigned int \&}]{max\+Row }\end{DoxyParamCaption})}



Manual\+Euclidean\+Distance\+Type no-\/utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo perteneciente a una clase específica manualmente. 

Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada \char`\"{}pos\char`\"{} y verificando que sea de tipo \char`\"{}type\char`\"{} con ayuda del vector de etiquetas \char`\"{}label\char`\"{} \begin{DoxySeeAlso}{Ver también}
\mbox{\hyperlink{mytools_8cpp_a4f5825bcc562c6dabe6c136863aedeca}{Manual\+Euclidean\+Distance(\+Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data,unsigned int pos, unsigned int \&max\+Row)}}; 
\end{DoxySeeAlso}
\mbox{\Hypertarget{mytools_8cpp_a435bbaf48f4140898c13da58ffa48ee4}\label{mytools_8cpp_a435bbaf48f4140898c13da58ffa48ee4}} 
\index{mytools.cpp@{mytools.cpp}!ManualEuclideanDistanceType@{ManualEuclideanDistanceType}}
\index{ManualEuclideanDistanceType@{ManualEuclideanDistanceType}!mytools.cpp@{mytools.cpp}}
\doxysubsubsection{\texorpdfstring{ManualEuclideanDistanceType()}{ManualEuclideanDistanceType()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double Manual\+Euclidean\+Distance\+Type (\begin{DoxyParamCaption}\item[{Eigen\+::\+Row\+Vector\+Xd}]{weights,  }\item[{Eigen\+::\+Row\+Vector\+Xd}]{fixed,  }\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{vector$<$ char $>$}]{label,  }\item[{char}]{type,  }\item[{unsigned int}]{pos,  }\item[{unsigned int \&}]{max\+Row }\end{DoxyParamCaption})}



Manual\+Euclidean\+Distance\+Type no-\/utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características y perteneciente a una clase específica manualmente. 

Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen multiplicado por el vector de características calculado, y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada \char`\"{}pos\char`\"{} y verificando que sea de tipo \char`\"{}type\char`\"{} con ayuda del vector de etiquetas \char`\"{}label\char`\"{} \begin{DoxySeeAlso}{Ver también}
double \mbox{\hyperlink{mytools_8cpp_a15615cc501cd57df609a342fe8cca7c2}{Manual\+Euclidean\+Distance\+Type(\+Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data,      vector$<$char$>$ label, char type,unsigned int pos, unsigned int \&max\+Row)}}; 
\end{DoxySeeAlso}
\mbox{\Hypertarget{mytools_8cpp_ad065fd64357444d7792b80876fcfa41f}\label{mytools_8cpp_ad065fd64357444d7792b80876fcfa41f}} 
\index{mytools.cpp@{mytools.cpp}!minEuclideanDistance@{minEuclideanDistance}}
\index{minEuclideanDistance@{minEuclideanDistance}!mytools.cpp@{mytools.cpp}}
\doxysubsubsection{\texorpdfstring{minEuclideanDistance()}{minEuclideanDistance()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double min\+Euclidean\+Distance (\begin{DoxyParamCaption}\item[{Eigen\+::\+Row\+Vector\+Xd}]{fixed,  }\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{Eigen\+::\+Matrix\+Xd\+::\+Index \&}]{max\+Row }\end{DoxyParamCaption})}



min\+Euclidean\+Distance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila \char`\"{}fixed\char`\"{} NO contenida en data. 

Usando la librería Eigen sabemos que podemos restarle a una fila un vector de tipe Row\+Vector\+Xd si activamos el calculo por filas con .rowwise() y además ese resultado podemos concatenarlo en vez de almacenarlo y llamar ahora a .squared\+Norm() que calcula la distancia euclidea al cuadrado. Sin embargo, también hemos de decir que la queremos por filas y no por columnas. Luego a continuación hacemos una llamada a min\+Coeff() que busca el valor mínimo resultante de las operaciones realizadas. \mbox{\Hypertarget{mytools_8cpp_a279ce1dc36aa76d8fe48671866b53dfa}\label{mytools_8cpp_a279ce1dc36aa76d8fe48671866b53dfa}} 
\index{mytools.cpp@{mytools.cpp}!minEuclideanDistance@{minEuclideanDistance}}
\index{minEuclideanDistance@{minEuclideanDistance}!mytools.cpp@{mytools.cpp}}
\doxysubsubsection{\texorpdfstring{minEuclideanDistance()}{minEuclideanDistance()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double min\+Euclidean\+Distance (\begin{DoxyParamCaption}\item[{Eigen\+::\+Row\+Vector\+Xd}]{weights,  }\item[{Eigen\+::\+Row\+Vector\+Xd}]{fixed,  }\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{Eigen\+::\+Matrix\+Xd\+::\+Index \&}]{max\+Row }\end{DoxyParamCaption})}



min\+Euclidean\+Distance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila \char`\"{}fixed\char`\"{} NO contenida en data multiplicando las distancias por el vector de características que las pondera. 

Hacemos el calculo de la distancia euclidea al cuadrado pero ahora multiplicamos cada parámetro por su respectivo peso que pondera sus características. \begin{DoxySeeAlso}{Ver también}
\mbox{\hyperlink{mytools_8cpp_ad065fd64357444d7792b80876fcfa41f}{min\+Euclidean\+Distance(\+Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data,\+Eigen\+::\+Matrix\+Xd\+::\+Index \&max\+Row)}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{mytools_8cpp_aef11c31862b1e9d5623ad9611548fd14}\label{mytools_8cpp_aef11c31862b1e9d5623ad9611548fd14}} 
\index{mytools.cpp@{mytools.cpp}!readValues@{readValues}}
\index{readValues@{readValues}!mytools.cpp@{mytools.cpp}}
\doxysubsubsection{\texorpdfstring{readValues()}{readValues()}}
{\footnotesize\ttfamily Eigen\+::\+Matrix\+Xd read\+Values (\begin{DoxyParamCaption}\item[{string}]{filename,  }\item[{vector$<$ char $>$ \&}]{label }\end{DoxyParamCaption})}



read\+Values es la función utilizada para leer los archivos \char`\"{}.\+arrf\char`\"{} de la práctia en una Matrix de la libreria \char`\"{}\+Eigen\char`\"{} y un vector de etiquetas \char`\"{}\+Label\char`\"{}. 

Leemos y utilizamos los \char`\"{}@attribute\char`\"{} del archivo para calcular el tamaño de las columnas de la matrix a rellenar. Luego al leer \char`\"{}@data\char`\"{} lo que haremos es empezar el bucle de rellenado. Dónde en este lo que hacemos es leer un número y una coma, insertar el número en un vector hasta que se alcanze la cantidad de valores calculadas. Luego lo insertamos en la última fila de la matrix y la incrementamos de tamaño para la siguiente iteración. Así hasta que terminemos de leer el archivo. \mbox{\Hypertarget{mytools_8cpp_a1b897fefb12470c87ac53ec826fe52cb}\label{mytools_8cpp_a1b897fefb12470c87ac53ec826fe52cb}} 
\index{mytools.cpp@{mytools.cpp}!removeColumn@{removeColumn}}
\index{removeColumn@{removeColumn}!mytools.cpp@{mytools.cpp}}
\doxysubsubsection{\texorpdfstring{removeColumn()}{removeColumn()}}
{\footnotesize\ttfamily Eigen\+::\+Matrix\+Xd remove\+Column (\begin{DoxyParamCaption}\item[{Eigen\+::\+Matrix\+Xd}]{matrix,  }\item[{unsigned int}]{col\+To\+Remove }\end{DoxyParamCaption})}

La función sobreescribe la columna con los valores que hay después de esa columna. Y Luego hace un resize para cambiar el tamaño original a una columna menos. \mbox{\Hypertarget{mytools_8cpp_a3176dc33dc79b493d699596ece0e1ef7}\label{mytools_8cpp_a3176dc33dc79b493d699596ece0e1ef7}} 
\index{mytools.cpp@{mytools.cpp}!removeRow@{removeRow}}
\index{removeRow@{removeRow}!mytools.cpp@{mytools.cpp}}
\doxysubsubsection{\texorpdfstring{removeRow()}{removeRow()}}
{\footnotesize\ttfamily Eigen\+::\+Matrix\+Xd remove\+Row (\begin{DoxyParamCaption}\item[{Eigen\+::\+Matrix\+Xd}]{matrix,  }\item[{unsigned int}]{row\+To\+Remove }\end{DoxyParamCaption})}



remove\+Row nos permite quitar una fila de una matrix de entrada (sin modificar la original) y devuelve la matrix resultante modificada. 

La función sobreescribe la fila con la matrix que hay después de esa fila. Y Luego hace un resize para cambiar el tamaño original a una fila menos. \mbox{\Hypertarget{mytools_8cpp_a29d852399058fecfd4506ac5173a8c2f}\label{mytools_8cpp_a29d852399058fecfd4506ac5173a8c2f}} 
\index{mytools.cpp@{mytools.cpp}!shuffleData@{shuffleData}}
\index{shuffleData@{shuffleData}!mytools.cpp@{mytools.cpp}}
\doxysubsubsection{\texorpdfstring{shuffleData()}{shuffleData()}}
{\footnotesize\ttfamily void shuffle\+Data (\begin{DoxyParamCaption}\item[{Matrix\+Xd \&}]{mat,  }\item[{vector$<$ char $>$ \&}]{label,  }\item[{long int}]{seed }\end{DoxyParamCaption})}



shuffle\+Data utiliza el archivo \char`\"{}random.\+hpp\char`\"{} y la librería Eigen para crear un vector de índices, al cual barajamos y luego utilizamos ese vector para intercambiar posiciones. Dónde el número que aparezca en la posición 0 es el intercambio de 0 con ese número y así. 

La idea es un vector de índices a permutar. Dónde el valor de la posición 0 es el índice a permutar con la posición 0. Si vector.\+at(0) = 2, intercambiamos 0 con el 2. 