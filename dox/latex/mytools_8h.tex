\hypertarget{mytools_8h}{}\doxysection{Referencia del Archivo tools/mytools.h}
\label{mytools_8h}\index{tools/mytools.h@{tools/mytools.h}}


Herramientas definidas para la práctica.  


{\ttfamily \#include \char`\"{}./eigen-\/3.\+4.\+0/\+Eigen/\+Dense\char`\"{}}\newline
{\ttfamily \#include \char`\"{}./random.\+hpp\char`\"{}}\newline
{\ttfamily \#include $<$string.\+h$>$}\newline
{\ttfamily \#include $<$vector$>$}\newline
\doxysubsection*{typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{mytools_8h_a180f0653ebd0d5cdf633574b8c8512d3}\label{mytools_8h_a180f0653ebd0d5cdf633574b8c8512d3}} 
using {\bfseries Random} = effolkronium\+::random\+\_\+static
\end{DoxyCompactItemize}
\doxysubsection*{Funciones}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{mytools_8h_ad81243b382bfc2358283ab0091c972c3}{fill\+Range}} (vector$<$ int $>$ \&to\+Fill, unsigned int upperlimit)
\begin{DoxyCompactList}\small\item\em fill\+Range rellena un vector de valores desde 0 hasta upperlimit; \end{DoxyCompactList}\item 
double \mbox{\hyperlink{mytools_8h_ad065fd64357444d7792b80876fcfa41f}{min\+Euclidean\+Distance}} (Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data, Eigen\+::\+Matrix\+Xd\+::\+Index \&max\+Row)
\begin{DoxyCompactList}\small\item\em min\+Euclidean\+Distance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila \char`\"{}fixed\char`\"{} NO contenida en data. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{mytools_8h_a5d0dd7bbe04f5f18dc592a11c536bb6b}{min\+Euclidean\+Distance}} (Eigen\+::\+Row\+Vector\+Xd weigths, Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data, Eigen\+::\+Matrix\+Xd\+::\+Index \&max\+Row)
\begin{DoxyCompactList}\small\item\em min\+Euclidean\+Distance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila \char`\"{}fixed\char`\"{} NO contenida en data multiplicando las distancias por el vector de características que las pondera. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{mytools_8h_a4f5825bcc562c6dabe6c136863aedeca}{Manual\+Euclidean\+Distance}} (Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data, unsigned int pos, unsigned int \&max\+Row)
\begin{DoxyCompactList}\small\item\em Manual\+Euclidean\+Distance no-\/utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo manualmente. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{mytools_8h_aa2fa99f7f091464475f3aa8c1a9f13b5}{Manual\+Euclidean\+Distance}} (Eigen\+::\+Row\+Vector\+Xd weigths, Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data, unsigned int pos, unsigned int \&max\+Row)
\begin{DoxyCompactList}\small\item\em Manual\+Euclidean\+Distance no-\/utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características manualmente. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{mytools_8h_acdf9d105d2e503df5b99f19eddcaca28}{Manual\+Euclidean\+Distance\+Type}} (Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data, vector$<$ char $>$label, char type, unsigned int pos, unsigned int \&max\+Row)
\begin{DoxyCompactList}\small\item\em Manual\+Euclidean\+Distance\+Type no-\/utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo perteneciente a una clase específica manualmente. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{mytools_8h_ac249d23e7dedd767338fd2733fe88c0c}{Manual\+Euclidean\+Distance\+Type}} (Eigen\+::\+Row\+Vector\+Xd weigths, Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data, vector$<$ char $>$label, char type, unsigned int pos, unsigned int \&max\+Row)
\begin{DoxyCompactList}\small\item\em Manual\+Euclidean\+Distance\+Type no-\/utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características y perteneciente a una clase específica manualmente. \end{DoxyCompactList}\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{mytools_8h_a3c2da117b6d8079659b9d6ba6e15fed7}{get\+Class}} (Eigen\+::\+Matrix\+Xd data, vector$<$ char $>$ label, char type)
\begin{DoxyCompactList}\small\item\em get\+Class lo que nos devuelve es una matrix con los datos pertenecientes a una clase específica. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{mytools_8h_a18d1ea164d65b34e0971e329b23fc3f0}\label{mytools_8h_a18d1ea164d65b34e0971e329b23fc3f0}} 
Eigen\+::\+Matrix\+Xd {\bfseries get\+Class\+Labelled} (Eigen\+::\+Matrix\+Xd data, vector$<$ char $>$ Label, vector$<$ char $>$ \&new\+Label, char type)
\item 
void \mbox{\hyperlink{mytools_8h_a84ae2c8440383fed7b4006741e91cff3}{get\+Fold}} (Eigen\+::\+Matrix\+Xd data, vector$<$ char $>$ Label, Eigen\+::\+Matrix\+Xd \&training, vector$<$ char $>$ \&TLabel, Eigen\+::\+Matrix\+Xd \&test, vector$<$ char $>$ \&Tt\+Label, unsigned int num=1)
\begin{DoxyCompactList}\small\item\em get\+Fold divide la matrix de datos \char`\"{}data\char`\"{} en dos matrices \char`\"{}tranning\char`\"{} y \char`\"{}test\char`\"{} con los datos pertenecientes a uno de los 5-\/folds que tenemos de desplazar un 20\% al grupo de test sobre el conjunto total \end{DoxyCompactList}\item 
void \mbox{\hyperlink{mytools_8h_a74e85088fcdeddd5575177adddcd564f}{get\+Foldby\+Loop}} (Eigen\+::\+Matrix\+Xd data, vector$<$ char $>$ Label, Eigen\+::\+Matrix\+Xd \&training, vector$<$ char $>$ \&TLabel, Eigen\+::\+Matrix\+Xd \&test, vector$<$ char $>$ \&Tt\+Label, unsigned int num)
\begin{DoxyCompactList}\small\item\em get\+Foldby\+Loop divide la matrix de datos \char`\"{}data\char`\"{} en dos matrices \char`\"{}tranning\char`\"{} y \char`\"{}test\char`\"{} con los datos pertenecientes a uno de los 5-\/folds que tenemos de desplazar un 20\% al grupo de test sobre el conjunto total. A diferencia de \mbox{\hyperlink{mytools_8h_a84ae2c8440383fed7b4006741e91cff3}{get\+Fold()}} intenta utilizar el \char`\"{}for-\/loop\char`\"{} de las etiquetas para asignar las filas. Sin embargo posee peor rendimiento. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{mytools_8h_a996e2cf1dca6d6f6b2e5004fd6c8f789}{get\+Balanced\+Fold}} (Eigen\+::\+Matrix\+Xd group1, vector$<$ char $>$ label1, Eigen\+::\+Matrix\+Xd group2, vector$<$ char $>$ label2, Eigen\+::\+Matrix\+Xd \&training, vector$<$ char $>$ \&TLabel, Eigen\+::\+Matrix\+Xd \&test, vector$<$ char $>$ \&Tt\+Label, unsigned int num, long int seed)
\item 
void \mbox{\hyperlink{mytools_8h_a29d852399058fecfd4506ac5173a8c2f}{shuffle\+Data}} (Matrix\+Xd \&mat, vector$<$ char $>$ \&label, long int seed)
\begin{DoxyCompactList}\small\item\em shuffle\+Data utiliza el archivo \char`\"{}random.\+hpp\char`\"{} y la librería Eigen para crear un vector de índices, al cual barajamos y luego utilizamos ese vector para intercambiar posiciones. Dónde el número que aparezca en la posición 0 es el intercambio de 0 con ese número y así. \end{DoxyCompactList}\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{mytools_8h_aef11c31862b1e9d5623ad9611548fd14}{read\+Values}} (string filename, vector$<$ char $>$ \&label)
\begin{DoxyCompactList}\small\item\em read\+Values es la función utilizada para leer los archivos \char`\"{}.\+arrf\char`\"{} de la práctia en una Matrix de la libreria \char`\"{}\+Eigen\char`\"{} y un vector de etiquetas \char`\"{}\+Label\char`\"{}. \end{DoxyCompactList}\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{mytools_8h_a3176dc33dc79b493d699596ece0e1ef7}{remove\+Row}} (Eigen\+::\+Matrix\+Xd matrix, unsigned int row\+To\+Remove)
\begin{DoxyCompactList}\small\item\em remove\+Row nos permite quitar una fila de una matrix de entrada (sin modificar la original) y devuelve la matrix resultante modificada. \end{DoxyCompactList}\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{mytools_8h_ab11c0c6f48347a29e1906bf38cb41131}{remove\+Col}} (Eigen\+::\+Matrix\+Xd matrix, unsigned int col\+To\+Remove)
\begin{DoxyCompactList}\small\item\em remove\+Row nos permite quitar una columna de una matrix de entrada (sin modificar la original) y devuelve la matrix resultante modificada. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Descripción detallada}
Herramientas definidas para la práctica. 

\begin{DoxyVersion}{Versión}
2.\+3 
\end{DoxyVersion}
\begin{DoxyDate}{Fecha}
05/04/2022 
\end{DoxyDate}
\begin{DoxyAuthor}{Autor}
Brian Sena Simons 3º\+A-\/\+A2 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()\{}
\DoxyCodeLine{ MatrixXd mat(3,2);}
\DoxyCodeLine{ mat << 1, 1,}
\DoxyCodeLine{        2, 2,}
\DoxyCodeLine{        4, 4;}
\DoxyCodeLine{}
\DoxyCodeLine{ RowVectorXd fil = \mbox{\hyperlink{mytools_8cpp_a3176dc33dc79b493d699596ece0e1ef7}{removeRow}}(mat,2);}
\DoxyCodeLine{ MatriXd::Index pos;}
\DoxyCodeLine{ \textcolor{keywordtype}{double} min = \mbox{\hyperlink{mytools_8cpp_ad065fd64357444d7792b80876fcfa41f}{minEuclideanDistance}}(fil,mat,pos);}
\DoxyCodeLine{ cout << \textcolor{stringliteral}{"{}Mínimo vecino por fila en: "{}} << pos << \textcolor{stringliteral}{"{} con valor: "{}} << min << endl;}
\DoxyCodeLine{\}}

\end{DoxyCode}
 
\end{DoxyAuthor}


\doxysubsection{Documentación de las funciones}
\mbox{\Hypertarget{mytools_8h_ad81243b382bfc2358283ab0091c972c3}\label{mytools_8h_ad81243b382bfc2358283ab0091c972c3}} 
\index{mytools.h@{mytools.h}!fillRange@{fillRange}}
\index{fillRange@{fillRange}!mytools.h@{mytools.h}}
\doxysubsubsection{\texorpdfstring{fillRange()}{fillRange()}}
{\footnotesize\ttfamily void fill\+Range (\begin{DoxyParamCaption}\item[{vector$<$ int $>$ \&}]{to\+Fill,  }\item[{unsigned int}]{upperlimit }\end{DoxyParamCaption})}



fill\+Range rellena un vector de valores desde 0 hasta upperlimit; 


\begin{DoxyParams}{Parámetros}
{\em to\+Fill} & es el vector a rellenar \\
\hline
{\em upperlimit} & es el valor tope del vector\\
\hline
\end{DoxyParams}
En esta función hacemos un simple \char`\"{}for-\/loop\char`\"{} hasta upperlimit dónde en cada iteración asignamos el valor \char`\"{}i\char`\"{} al vector generando una sucesión de 0-\/upperlimit. \mbox{\Hypertarget{mytools_8h_a996e2cf1dca6d6f6b2e5004fd6c8f789}\label{mytools_8h_a996e2cf1dca6d6f6b2e5004fd6c8f789}} 
\index{mytools.h@{mytools.h}!getBalancedFold@{getBalancedFold}}
\index{getBalancedFold@{getBalancedFold}!mytools.h@{mytools.h}}
\doxysubsubsection{\texorpdfstring{getBalancedFold()}{getBalancedFold()}}
{\footnotesize\ttfamily void get\+Balanced\+Fold (\begin{DoxyParamCaption}\item[{Eigen\+::\+Matrix\+Xd}]{group1,  }\item[{vector$<$ char $>$}]{label1,  }\item[{Eigen\+::\+Matrix\+Xd}]{group2,  }\item[{vector$<$ char $>$}]{label2,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{training,  }\item[{vector$<$ char $>$ \&}]{TLabel,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{test,  }\item[{vector$<$ char $>$ \&}]{Tt\+Label,  }\item[{unsigned int}]{num,  }\item[{long int}]{seed }\end{DoxyParamCaption})}

Hace lo mismo que \mbox{\hyperlink{mytools_8cpp_ac7830bddd694d4aeb550f74ffc23528d}{get\+Fold()}} pero con un equilibrado de clase de por medio; Se utiliza \mbox{\hyperlink{mytools_8cpp_abdfd60b2dabf33b1de7720bceaea78dc}{get\+Class()}} para obtener matrices correspondente a cada clase, se pasa a este método y lo para cada conjunto utiliza \mbox{\hyperlink{mytools_8cpp_ac7830bddd694d4aeb550f74ffc23528d}{get\+Fold()}} para obtener su correspondente 80/20 y luego lo añade todo secuencialmente en el conjunto de entreno y testeo que luego a final son barajados. \mbox{\Hypertarget{mytools_8h_a3c2da117b6d8079659b9d6ba6e15fed7}\label{mytools_8h_a3c2da117b6d8079659b9d6ba6e15fed7}} 
\index{mytools.h@{mytools.h}!getClass@{getClass}}
\index{getClass@{getClass}!mytools.h@{mytools.h}}
\doxysubsubsection{\texorpdfstring{getClass()}{getClass()}}
{\footnotesize\ttfamily Eigen\+::\+Matrix\+Xd get\+Class (\begin{DoxyParamCaption}\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{vector$<$ char $>$}]{Label,  }\item[{char}]{type }\end{DoxyParamCaption})}



get\+Class lo que nos devuelve es una matrix con los datos pertenecientes a una clase específica. 


\begin{DoxyParams}{Parámetros}
{\em data} & Matrix de datos completos. \\
\hline
{\em label} & Vector de etiquetas. \\
\hline
{\em type} & Clase específica a buscar. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Devuelve}
Matrix con los datos de esa clase
\end{DoxyReturn}
La idea es iterar sobre el vector de etiquetas y cuando su valor coincida con el especificado por \char`\"{}type\char`\"{} introducimos en la matrix \char`\"{}res\char`\"{} la fila correspondiente para así calcular la matrix con apenas un tipo de clase. \mbox{\Hypertarget{mytools_8h_a84ae2c8440383fed7b4006741e91cff3}\label{mytools_8h_a84ae2c8440383fed7b4006741e91cff3}} 
\index{mytools.h@{mytools.h}!getFold@{getFold}}
\index{getFold@{getFold}!mytools.h@{mytools.h}}
\doxysubsubsection{\texorpdfstring{getFold()}{getFold()}}
{\footnotesize\ttfamily void get\+Fold (\begin{DoxyParamCaption}\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{vector$<$ char $>$}]{Label,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{training,  }\item[{vector$<$ char $>$ \&}]{TLabel,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{test,  }\item[{vector$<$ char $>$ \&}]{Tt\+Label,  }\item[{unsigned int}]{num }\end{DoxyParamCaption})}



get\+Fold divide la matrix de datos \char`\"{}data\char`\"{} en dos matrices \char`\"{}tranning\char`\"{} y \char`\"{}test\char`\"{} con los datos pertenecientes a uno de los 5-\/folds que tenemos de desplazar un 20\% al grupo de test sobre el conjunto total 


\begin{DoxyParams}{Parámetros}
{\em data} & Matrix de datos completos. \\
\hline
{\em label} & Vector de etiquetas. \\
\hline
{\em traning} & Matrix con los datos para entrenar. \\
\hline
{\em Tlabel} & Vector con las etiquetas de entreno. \\
\hline
{\em test} & Matrix con los datos para el test. \\
\hline
{\em Ttlabel} & Vector con las etiquetas de test. \\
\hline
{\em num} & Fold a utilizar (0\+:(0-\/80\%;80\%-\/100\%), 1\+:(0\+:60\%+80\%-\/100\%;60\%-\/80\%)...)\\
\hline
\end{DoxyParams}
La idea es calcular el 20\% de la Matrix total y luego con ese valor ir estableciendo el \char`\"{}boundary\char`\"{} superior a copiar para la primera (o toda la parte del dataset de entreno cuando num=0, boundary = 80\%) y luego copiar lo que sigue a boundary hasta un 20\% más (boundary + size) en test y luego copiar devuelta lo que queda en tranning. Utilizamos la librería de Eigen para un mejor rendimiento. \mbox{\Hypertarget{mytools_8h_a74e85088fcdeddd5575177adddcd564f}\label{mytools_8h_a74e85088fcdeddd5575177adddcd564f}} 
\index{mytools.h@{mytools.h}!getFoldbyLoop@{getFoldbyLoop}}
\index{getFoldbyLoop@{getFoldbyLoop}!mytools.h@{mytools.h}}
\doxysubsubsection{\texorpdfstring{getFoldbyLoop()}{getFoldbyLoop()}}
{\footnotesize\ttfamily void get\+Foldby\+Loop (\begin{DoxyParamCaption}\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{vector$<$ char $>$}]{Label,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{training,  }\item[{vector$<$ char $>$ \&}]{TLabel,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{test,  }\item[{vector$<$ char $>$ \&}]{Tt\+Label,  }\item[{unsigned int}]{num }\end{DoxyParamCaption})}



get\+Foldby\+Loop divide la matrix de datos \char`\"{}data\char`\"{} en dos matrices \char`\"{}tranning\char`\"{} y \char`\"{}test\char`\"{} con los datos pertenecientes a uno de los 5-\/folds que tenemos de desplazar un 20\% al grupo de test sobre el conjunto total. A diferencia de \mbox{\hyperlink{mytools_8h_a84ae2c8440383fed7b4006741e91cff3}{get\+Fold()}} intenta utilizar el \char`\"{}for-\/loop\char`\"{} de las etiquetas para asignar las filas. Sin embargo posee peor rendimiento. 


\begin{DoxyParams}{Parámetros}
{\em data} & Matrix de datos completos. \\
\hline
{\em label} & Vector de etiquetas. \\
\hline
{\em traning} & Matrix con los datos para entrenar. \\
\hline
{\em Tlabel} & Vector con las etiquetas de entreno. \\
\hline
{\em test} & Matrix con los datos para el test. \\
\hline
{\em Ttlabel} & Vector con las etiquetas de test. \\
\hline
{\em num} & Fold a utilizar (0\+:(0-\/80\%;80\%-\/100\%), 1\+:(0\+:60\%+80\%-\/100\%;60\%-\/80\%)...) \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{Ver también}
\mbox{\hyperlink{mytools_8cpp_ac7830bddd694d4aeb550f74ffc23528d}{get\+Fold()}}
\end{DoxySeeAlso}
La idea es calcular el 20\% de la Matrix total y luego con ese valor ir estableciendo el \char`\"{}boundary\char`\"{} superior a copiar para la primera (o toda la parte del dataset de entreno cuando num=0, boundary = 80\%) y luego copiar lo que sigue a boundary hasta un 20\% más (boundary + size) en test y luego copiar devuelta lo que queda en tranning. Pero en este caso no utilizamos las facilidades de la librería Eigen si no que apenas calculamos el tamaño total de las matrices a rellenar y vamos iterando a la vez que creamos las etiquetas adecuadas. \mbox{\Hypertarget{mytools_8h_a4f5825bcc562c6dabe6c136863aedeca}\label{mytools_8h_a4f5825bcc562c6dabe6c136863aedeca}} 
\index{mytools.h@{mytools.h}!ManualEuclideanDistance@{ManualEuclideanDistance}}
\index{ManualEuclideanDistance@{ManualEuclideanDistance}!mytools.h@{mytools.h}}
\doxysubsubsection{\texorpdfstring{ManualEuclideanDistance()}{ManualEuclideanDistance()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double Manual\+Euclidean\+Distance (\begin{DoxyParamCaption}\item[{Eigen\+::\+Row\+Vector\+Xd}]{fixed,  }\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{unsigned int}]{pos,  }\item[{unsigned int \&}]{max\+Row }\end{DoxyParamCaption})}



Manual\+Euclidean\+Distance no-\/utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo manualmente. 


\begin{DoxyParams}{Parámetros}
{\em weights} & es el vector de pesos característicos a multiplicar \\
\hline
{\em fixed} & Fila a buscar contenida en data. \\
\hline
{\em data} & Matrix de datos a verificar vecinos. \\
\hline
{\em pos} & Fila de la que provee fixed. \\
\hline
{\em max\+Row} & es el ínidice de la fila más cercana encontrada. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Devuelve}
el valor mínimo. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{Ver también}
\mbox{\hyperlink{mytools_8cpp_ad065fd64357444d7792b80876fcfa41f}{min\+Euclidean\+Distance(\+Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data,\+Eigen\+::\+Matrix\+Xd\+::\+Index \&max\+Row)}};
\end{DoxySeeAlso}
Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada \char`\"{}pos\char`\"{}. \begin{DoxySeeAlso}{Ver también}
\mbox{\hyperlink{mytools_8cpp_ad065fd64357444d7792b80876fcfa41f}{min\+Euclidean\+Distance(\+Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data,\+Eigen\+::\+Matrix\+Xd\+::\+Index \&max\+Row)}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{mytools_8h_aa2fa99f7f091464475f3aa8c1a9f13b5}\label{mytools_8h_aa2fa99f7f091464475f3aa8c1a9f13b5}} 
\index{mytools.h@{mytools.h}!ManualEuclideanDistance@{ManualEuclideanDistance}}
\index{ManualEuclideanDistance@{ManualEuclideanDistance}!mytools.h@{mytools.h}}
\doxysubsubsection{\texorpdfstring{ManualEuclideanDistance()}{ManualEuclideanDistance()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double Manual\+Euclidean\+Distance (\begin{DoxyParamCaption}\item[{Eigen\+::\+Row\+Vector\+Xd}]{weights,  }\item[{Eigen\+::\+Row\+Vector\+Xd}]{fixed,  }\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{unsigned int}]{pos,  }\item[{unsigned int \&}]{max\+Row }\end{DoxyParamCaption})}



Manual\+Euclidean\+Distance no-\/utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características manualmente. 


\begin{DoxyParams}{Parámetros}
{\em weights} & es el vector de pesos característicos a multiplicar \\
\hline
{\em fixed} & Fila a buscar contenida en data. \\
\hline
{\em data} & Matrix de datos a verificar vecinos. \\
\hline
{\em pos} & Fila de la que provee fixed. \\
\hline
{\em max\+Row} & es el ínidice de la fila más cercana encontrada. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Devuelve}
el valor mínimo. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{Ver también}
double \mbox{\hyperlink{mytools_8cpp_a4f5825bcc562c6dabe6c136863aedeca}{Manual\+Euclidean\+Distance(\+Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data,unsigned int pos,unsigned int \&max\+Row)}};
\end{DoxySeeAlso}
Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen ponderado por los pesos característicos calculados y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada \char`\"{}pos\char`\"{}. \begin{DoxySeeAlso}{Ver también}
\mbox{\hyperlink{mytools_8cpp_a4f5825bcc562c6dabe6c136863aedeca}{Manual\+Euclidean\+Distance(\+Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data,unsigned int pos, unsigned int \&max\+Row)}}; 
\end{DoxySeeAlso}
\mbox{\Hypertarget{mytools_8h_acdf9d105d2e503df5b99f19eddcaca28}\label{mytools_8h_acdf9d105d2e503df5b99f19eddcaca28}} 
\index{mytools.h@{mytools.h}!ManualEuclideanDistanceType@{ManualEuclideanDistanceType}}
\index{ManualEuclideanDistanceType@{ManualEuclideanDistanceType}!mytools.h@{mytools.h}}
\doxysubsubsection{\texorpdfstring{ManualEuclideanDistanceType()}{ManualEuclideanDistanceType()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double Manual\+Euclidean\+Distance\+Type (\begin{DoxyParamCaption}\item[{Eigen\+::\+Row\+Vector\+Xd}]{fixed,  }\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{vector$<$ char $>$}]{label,  }\item[{char}]{type,  }\item[{unsigned int}]{pos,  }\item[{unsigned int \&}]{max\+Row }\end{DoxyParamCaption})}



Manual\+Euclidean\+Distance\+Type no-\/utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo perteneciente a una clase específica manualmente. 


\begin{DoxyParams}{Parámetros}
{\em weights} & es el vector de pesos característicos a multiplicar \\
\hline
{\em fixed} & Fila a buscar contenida en data. \\
\hline
{\em data} & Matrix de datos a verificar vecinos. \\
\hline
{\em label} & Vector de etiquetas. \\
\hline
{\em type} & Clase a buscar. \\
\hline
{\em pos} & Fila de la que provee fixed. \\
\hline
{\em max\+Row} & es el ínidice de la fila más cercana encontrada. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Devuelve}
el valor mínimo. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{Ver también}
double \mbox{\hyperlink{mytools_8cpp_a4f5825bcc562c6dabe6c136863aedeca}{Manual\+Euclidean\+Distance(\+Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data,unsigned int pos,unsigned int \&max\+Row)}};
\end{DoxySeeAlso}
Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada \char`\"{}pos\char`\"{} y verificando que sea de tipo \char`\"{}type\char`\"{} con ayuda del vector de etiquetas \char`\"{}label\char`\"{} \begin{DoxySeeAlso}{Ver también}
\mbox{\hyperlink{mytools_8cpp_a4f5825bcc562c6dabe6c136863aedeca}{Manual\+Euclidean\+Distance(\+Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data,unsigned int pos, unsigned int \&max\+Row)}}; 
\end{DoxySeeAlso}
\mbox{\Hypertarget{mytools_8h_ac249d23e7dedd767338fd2733fe88c0c}\label{mytools_8h_ac249d23e7dedd767338fd2733fe88c0c}} 
\index{mytools.h@{mytools.h}!ManualEuclideanDistanceType@{ManualEuclideanDistanceType}}
\index{ManualEuclideanDistanceType@{ManualEuclideanDistanceType}!mytools.h@{mytools.h}}
\doxysubsubsection{\texorpdfstring{ManualEuclideanDistanceType()}{ManualEuclideanDistanceType()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double Manual\+Euclidean\+Distance\+Type (\begin{DoxyParamCaption}\item[{Eigen\+::\+Row\+Vector\+Xd}]{weights,  }\item[{Eigen\+::\+Row\+Vector\+Xd}]{fixed,  }\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{vector$<$ char $>$}]{label,  }\item[{char}]{type,  }\item[{unsigned int}]{pos,  }\item[{unsigned int \&}]{max\+Row }\end{DoxyParamCaption})}



Manual\+Euclidean\+Distance\+Type no-\/utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características y perteneciente a una clase específica manualmente. 


\begin{DoxyParams}{Parámetros}
{\em weights} & es el vector de pesos característicos a multiplicar \\
\hline
{\em fixed} & Fila a buscar contenida en data. \\
\hline
{\em data} & Matrix de datos a verificar vecinos. \\
\hline
{\em label} & Vector de etiquetas. \\
\hline
{\em type} & Clase a buscar. \\
\hline
{\em pos} & Fila de la que provee fixed. \\
\hline
{\em max\+Row} & es el ínidice de la fila más cercana encontrada. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Devuelve}
el valor mínimo. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{Ver también}
double \mbox{\hyperlink{mytools_8cpp_a15615cc501cd57df609a342fe8cca7c2}{Manual\+Euclidean\+Distance\+Type(\+Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data,vector$<$char$>$label, char type, unsigned int pos, unsigned int \&max\+Row)}};
\end{DoxySeeAlso}
Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen multiplicado por el vector de características calculado, y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada \char`\"{}pos\char`\"{} y verificando que sea de tipo \char`\"{}type\char`\"{} con ayuda del vector de etiquetas \char`\"{}label\char`\"{} \begin{DoxySeeAlso}{Ver también}
double \mbox{\hyperlink{mytools_8cpp_a15615cc501cd57df609a342fe8cca7c2}{Manual\+Euclidean\+Distance\+Type(\+Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data,      vector$<$char$>$ label, char type,unsigned int pos, unsigned int \&max\+Row)}}; 
\end{DoxySeeAlso}
\mbox{\Hypertarget{mytools_8h_ad065fd64357444d7792b80876fcfa41f}\label{mytools_8h_ad065fd64357444d7792b80876fcfa41f}} 
\index{mytools.h@{mytools.h}!minEuclideanDistance@{minEuclideanDistance}}
\index{minEuclideanDistance@{minEuclideanDistance}!mytools.h@{mytools.h}}
\doxysubsubsection{\texorpdfstring{minEuclideanDistance()}{minEuclideanDistance()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double min\+Euclidean\+Distance (\begin{DoxyParamCaption}\item[{Eigen\+::\+Row\+Vector\+Xd}]{fixed,  }\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{Eigen\+::\+Matrix\+Xd\+::\+Index \&}]{max\+Row }\end{DoxyParamCaption})}



min\+Euclidean\+Distance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila \char`\"{}fixed\char`\"{} NO contenida en data. 


\begin{DoxyParams}{Parámetros}
{\em fixed} & Fila a buscar NO contenida en data. \\
\hline
{\em data} & Matrix de datos a verificar vecinos. \\
\hline
{\em max\+Row} & es el ínidice de la fila más cercana encontrada. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Devuelve}
el valor mínimo.
\end{DoxyReturn}
Usando la librería Eigen sabemos que podemos restarle a una fila un vector de tipe Row\+Vector\+Xd si activamos el calculo por filas con .rowwise() y además ese resultado podemos concatenarlo en vez de almacenarlo y llamar ahora a .squared\+Norm() que calcula la distancia euclidea al cuadrado. Sin embargo, también hemos de decir que la queremos por filas y no por columnas. Luego a continuación hacemos una llamada a min\+Coeff() que busca el valor mínimo resultante de las operaciones realizadas. \mbox{\Hypertarget{mytools_8h_a5d0dd7bbe04f5f18dc592a11c536bb6b}\label{mytools_8h_a5d0dd7bbe04f5f18dc592a11c536bb6b}} 
\index{mytools.h@{mytools.h}!minEuclideanDistance@{minEuclideanDistance}}
\index{minEuclideanDistance@{minEuclideanDistance}!mytools.h@{mytools.h}}
\doxysubsubsection{\texorpdfstring{minEuclideanDistance()}{minEuclideanDistance()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily double min\+Euclidean\+Distance (\begin{DoxyParamCaption}\item[{Eigen\+::\+Row\+Vector\+Xd}]{weights,  }\item[{Eigen\+::\+Row\+Vector\+Xd}]{fixed,  }\item[{Eigen\+::\+Matrix\+Xd}]{data,  }\item[{Eigen\+::\+Matrix\+Xd\+::\+Index \&}]{max\+Row }\end{DoxyParamCaption})}



min\+Euclidean\+Distance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila \char`\"{}fixed\char`\"{} NO contenida en data multiplicando las distancias por el vector de características que las pondera. 


\begin{DoxyParams}{Parámetros}
{\em weights} & es el vector de pesos característicos a multiplicar \\
\hline
{\em fixed} & Fila a buscar NO contenida en data. \\
\hline
{\em data} & Matrix de datos a verificar vecinos. \\
\hline
{\em max\+Row} & es el ínidice de la fila más cercana encontrada. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Devuelve}
el valor mínimo. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{Ver también}
\mbox{\hyperlink{mytools_8cpp_ad065fd64357444d7792b80876fcfa41f}{min\+Euclidean\+Distance(\+Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data,\+Eigen\+::\+Matrix\+Xd\+::\+Index \&max\+Row)}};
\end{DoxySeeAlso}
Hacemos el calculo de la distancia euclidea al cuadrado pero ahora multiplicamos cada parámetro por su respectivo peso que pondera sus características. \begin{DoxySeeAlso}{Ver también}
\mbox{\hyperlink{mytools_8cpp_ad065fd64357444d7792b80876fcfa41f}{min\+Euclidean\+Distance(\+Eigen\+::\+Row\+Vector\+Xd fixed, Eigen\+::\+Matrix\+Xd data,\+Eigen\+::\+Matrix\+Xd\+::\+Index \&max\+Row)}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{mytools_8h_aef11c31862b1e9d5623ad9611548fd14}\label{mytools_8h_aef11c31862b1e9d5623ad9611548fd14}} 
\index{mytools.h@{mytools.h}!readValues@{readValues}}
\index{readValues@{readValues}!mytools.h@{mytools.h}}
\doxysubsubsection{\texorpdfstring{readValues()}{readValues()}}
{\footnotesize\ttfamily Eigen\+::\+Matrix\+Xd read\+Values (\begin{DoxyParamCaption}\item[{string}]{filename,  }\item[{vector$<$ char $>$ \&}]{label }\end{DoxyParamCaption})}



read\+Values es la función utilizada para leer los archivos \char`\"{}.\+arrf\char`\"{} de la práctia en una Matrix de la libreria \char`\"{}\+Eigen\char`\"{} y un vector de etiquetas \char`\"{}\+Label\char`\"{}. 


\begin{DoxyParams}{Parámetros}
{\em filename} & Nombre del archivo que vamos a leer \\
\hline
{\em label} & Vector de etiquetas a rellenar. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Devuelve}
Matrix con todos los valores.
\end{DoxyReturn}
Leemos y utilizamos los \char`\"{}@attribute\char`\"{} del archivo para calcular el tamaño de las columnas de la matrix a rellenar. Luego al leer \char`\"{}@data\char`\"{} lo que haremos es empezar el bucle de rellenado. Dónde en este lo que hacemos es leer un número y una coma, insertar el número en un vector hasta que se alcanze la cantidad de valores calculadas. Luego lo insertamos en la última fila de la matrix y la incrementamos de tamaño para la siguiente iteración. Así hasta que terminemos de leer el archivo. \mbox{\Hypertarget{mytools_8h_ab11c0c6f48347a29e1906bf38cb41131}\label{mytools_8h_ab11c0c6f48347a29e1906bf38cb41131}} 
\index{mytools.h@{mytools.h}!removeCol@{removeCol}}
\index{removeCol@{removeCol}!mytools.h@{mytools.h}}
\doxysubsubsection{\texorpdfstring{removeCol()}{removeCol()}}
{\footnotesize\ttfamily Eigen\+::\+Matrix\+Xd remove\+Col (\begin{DoxyParamCaption}\item[{Eigen\+::\+Matrix\+Xd}]{matrix,  }\item[{unsigned int}]{col\+To\+Remove }\end{DoxyParamCaption})}



remove\+Row nos permite quitar una columna de una matrix de entrada (sin modificar la original) y devuelve la matrix resultante modificada. 


\begin{DoxyParams}{Parámetros}
{\em matrix} & Matrix con los datos completos. \\
\hline
{\em col\+To\+Remove} & Columna a quitar. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Devuelve}
Matrix modificada resultante 
\end{DoxyReturn}
\mbox{\Hypertarget{mytools_8h_a3176dc33dc79b493d699596ece0e1ef7}\label{mytools_8h_a3176dc33dc79b493d699596ece0e1ef7}} 
\index{mytools.h@{mytools.h}!removeRow@{removeRow}}
\index{removeRow@{removeRow}!mytools.h@{mytools.h}}
\doxysubsubsection{\texorpdfstring{removeRow()}{removeRow()}}
{\footnotesize\ttfamily Eigen\+::\+Matrix\+Xd remove\+Row (\begin{DoxyParamCaption}\item[{Eigen\+::\+Matrix\+Xd}]{matrix,  }\item[{unsigned int}]{row\+To\+Remove }\end{DoxyParamCaption})}



remove\+Row nos permite quitar una fila de una matrix de entrada (sin modificar la original) y devuelve la matrix resultante modificada. 


\begin{DoxyParams}{Parámetros}
{\em matrix} & Matrix con los datos completos. \\
\hline
{\em row\+To\+Remove} & Fila a quitar. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Devuelve}
Matrix modificada resultante
\end{DoxyReturn}
La función sobreescribe la fila con la matrix que hay después de esa fila. Y Luego hace un resize para cambiar el tamaño original a una fila menos. \mbox{\Hypertarget{mytools_8h_a29d852399058fecfd4506ac5173a8c2f}\label{mytools_8h_a29d852399058fecfd4506ac5173a8c2f}} 
\index{mytools.h@{mytools.h}!shuffleData@{shuffleData}}
\index{shuffleData@{shuffleData}!mytools.h@{mytools.h}}
\doxysubsubsection{\texorpdfstring{shuffleData()}{shuffleData()}}
{\footnotesize\ttfamily void shuffle\+Data (\begin{DoxyParamCaption}\item[{Matrix\+Xd \&}]{mat,  }\item[{vector$<$ char $>$ \&}]{label,  }\item[{long int}]{seed }\end{DoxyParamCaption})}



shuffle\+Data utiliza el archivo \char`\"{}random.\+hpp\char`\"{} y la librería Eigen para crear un vector de índices, al cual barajamos y luego utilizamos ese vector para intercambiar posiciones. Dónde el número que aparezca en la posición 0 es el intercambio de 0 con ese número y así. 


\begin{DoxyParams}{Parámetros}
{\em mat} & Matrix a permutar filas. @parm label Vector de etiquetas a intercambiar valores. \\
\hline
{\em seed} & Semilla para la función Random\\
\hline
\end{DoxyParams}
La idea es un vector de índices a permutar. Dónde el valor de la posición 0 es el índice a permutar con la posición 0. Si vector.\+at(0) = 2, intercambiamos 0 con el 2. 