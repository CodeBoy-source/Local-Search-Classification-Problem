<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Práctica de Metaheurística: Referencia del Archivo tools/mytools.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Práctica de Metaheurística<span id="projectnumber">&#160;1</span>
   </div>
   <div id="projectbrief">APC Clasification Problem, Greedy vs LocalSearch</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Buscar','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Buscar');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4eeb864c4eec08c7d6b9d3b0352cfdde.html">tools</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">typedefs</a> &#124;
<a href="#func-members">Funciones</a>  </div>
  <div class="headertitle"><div class="title">Referencia del Archivo mytools.h</div></div>
</div><!--header-->
<div class="contents">

<p>Herramientas definidas para la práctica.  
<a href="#details">Más...</a></p>
<div class="textblock"><code>#include &quot;./eigen-3.4.0/Eigen/Dense&quot;</code><br />
<code>#include &quot;./random.hpp&quot;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div>
<p><a href="mytools_8h_source.html">Ir al código fuente de este archivo.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
typedefs</h2></td></tr>
<tr class="memitem:a180f0653ebd0d5cdf633574b8c8512d3"><td class="memItemLeft" align="right" valign="top"><a id="a180f0653ebd0d5cdf633574b8c8512d3" name="a180f0653ebd0d5cdf633574b8c8512d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Random</b> = effolkronium::random_static</td></tr>
<tr class="separator:a180f0653ebd0d5cdf633574b8c8512d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Funciones</h2></td></tr>
<tr class="memitem:ad81243b382bfc2358283ab0091c972c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mytools_8h.html#ad81243b382bfc2358283ab0091c972c3">fillRange</a> (vector&lt; int &gt; &amp;toFill, unsigned int upperlimit)</td></tr>
<tr class="memdesc:ad81243b382bfc2358283ab0091c972c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">fillRange rellena un vector de valores desde 0 hasta upperlimit;  <a href="mytools_8h.html#ad81243b382bfc2358283ab0091c972c3">Más...</a><br /></td></tr>
<tr class="separator:ad81243b382bfc2358283ab0091c972c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad065fd64357444d7792b80876fcfa41f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mytools_8h.html#ad065fd64357444d7792b80876fcfa41f">minEuclideanDistance</a> (Eigen::RowVectorXd fixed, Eigen::MatrixXd data, Eigen::MatrixXd::Index &amp;maxRow)</td></tr>
<tr class="memdesc:ad065fd64357444d7792b80876fcfa41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila "fixed" NO contenida en data.  <a href="mytools_8h.html#ad065fd64357444d7792b80876fcfa41f">Más...</a><br /></td></tr>
<tr class="separator:ad065fd64357444d7792b80876fcfa41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0dd7bbe04f5f18dc592a11c536bb6b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mytools_8h.html#a5d0dd7bbe04f5f18dc592a11c536bb6b">minEuclideanDistance</a> (Eigen::RowVectorXd weigths, Eigen::RowVectorXd fixed, Eigen::MatrixXd data, Eigen::MatrixXd::Index &amp;maxRow)</td></tr>
<tr class="memdesc:a5d0dd7bbe04f5f18dc592a11c536bb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila "fixed" NO contenida en data multiplicando las distancias por el vector de características que las pondera.  <a href="mytools_8h.html#a5d0dd7bbe04f5f18dc592a11c536bb6b">Más...</a><br /></td></tr>
<tr class="separator:a5d0dd7bbe04f5f18dc592a11c536bb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5825bcc562c6dabe6c136863aedeca"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mytools_8h.html#a4f5825bcc562c6dabe6c136863aedeca">ManualEuclideanDistance</a> (Eigen::RowVectorXd fixed, Eigen::MatrixXd data, unsigned int pos, unsigned int &amp;maxRow)</td></tr>
<tr class="memdesc:a4f5825bcc562c6dabe6c136863aedeca"><td class="mdescLeft">&#160;</td><td class="mdescRight">ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo manualmente.  <a href="mytools_8h.html#a4f5825bcc562c6dabe6c136863aedeca">Más...</a><br /></td></tr>
<tr class="separator:a4f5825bcc562c6dabe6c136863aedeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fa99f7f091464475f3aa8c1a9f13b5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mytools_8h.html#aa2fa99f7f091464475f3aa8c1a9f13b5">ManualEuclideanDistance</a> (Eigen::RowVectorXd weigths, Eigen::RowVectorXd fixed, Eigen::MatrixXd data, unsigned int pos, unsigned int &amp;maxRow)</td></tr>
<tr class="memdesc:aa2fa99f7f091464475f3aa8c1a9f13b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características manualmente.  <a href="mytools_8h.html#aa2fa99f7f091464475f3aa8c1a9f13b5">Más...</a><br /></td></tr>
<tr class="separator:aa2fa99f7f091464475f3aa8c1a9f13b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf9d105d2e503df5b99f19eddcaca28"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mytools_8h.html#acdf9d105d2e503df5b99f19eddcaca28">ManualEuclideanDistanceType</a> (Eigen::RowVectorXd fixed, Eigen::MatrixXd data, vector&lt; char &gt;label, char type, unsigned int pos, unsigned int &amp;maxRow)</td></tr>
<tr class="memdesc:acdf9d105d2e503df5b99f19eddcaca28"><td class="mdescLeft">&#160;</td><td class="mdescRight">ManualEuclideanDistanceType no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo perteneciente a una clase específica manualmente.  <a href="mytools_8h.html#acdf9d105d2e503df5b99f19eddcaca28">Más...</a><br /></td></tr>
<tr class="separator:acdf9d105d2e503df5b99f19eddcaca28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac249d23e7dedd767338fd2733fe88c0c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mytools_8h.html#ac249d23e7dedd767338fd2733fe88c0c">ManualEuclideanDistanceType</a> (Eigen::RowVectorXd weigths, Eigen::RowVectorXd fixed, Eigen::MatrixXd data, vector&lt; char &gt;label, char type, unsigned int pos, unsigned int &amp;maxRow)</td></tr>
<tr class="memdesc:ac249d23e7dedd767338fd2733fe88c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ManualEuclideanDistanceType no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características y perteneciente a una clase específica manualmente.  <a href="mytools_8h.html#ac249d23e7dedd767338fd2733fe88c0c">Más...</a><br /></td></tr>
<tr class="separator:ac249d23e7dedd767338fd2733fe88c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2da117b6d8079659b9d6ba6e15fed7"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mytools_8h.html#a3c2da117b6d8079659b9d6ba6e15fed7">getClass</a> (Eigen::MatrixXd data, vector&lt; char &gt; label, char type)</td></tr>
<tr class="memdesc:a3c2da117b6d8079659b9d6ba6e15fed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">getClass lo que nos devuelve es una matrix con los datos pertenecientes a una clase específica.  <a href="mytools_8h.html#a3c2da117b6d8079659b9d6ba6e15fed7">Más...</a><br /></td></tr>
<tr class="separator:a3c2da117b6d8079659b9d6ba6e15fed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d1ea164d65b34e0971e329b23fc3f0"><td class="memItemLeft" align="right" valign="top"><a id="a18d1ea164d65b34e0971e329b23fc3f0" name="a18d1ea164d65b34e0971e329b23fc3f0"></a>
Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>getClassLabelled</b> (Eigen::MatrixXd data, vector&lt; char &gt; Label, vector&lt; char &gt; &amp;newLabel, char type)</td></tr>
<tr class="separator:a18d1ea164d65b34e0971e329b23fc3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ae2c8440383fed7b4006741e91cff3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mytools_8h.html#a84ae2c8440383fed7b4006741e91cff3">getFold</a> (Eigen::MatrixXd data, vector&lt; char &gt; Label, Eigen::MatrixXd &amp;training, vector&lt; char &gt; &amp;TLabel, Eigen::MatrixXd &amp;test, vector&lt; char &gt; &amp;TtLabel, unsigned int num=1)</td></tr>
<tr class="memdesc:a84ae2c8440383fed7b4006741e91cff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">getFold divide la matrix de datos "data" en dos matrices "tranning" y "test" con los datos pertenecientes a uno de los 5-folds que tenemos de desplazar un 20% al grupo de test sobre el conjunto total  <a href="mytools_8h.html#a84ae2c8440383fed7b4006741e91cff3">Más...</a><br /></td></tr>
<tr class="separator:a84ae2c8440383fed7b4006741e91cff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e85088fcdeddd5575177adddcd564f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mytools_8h.html#a74e85088fcdeddd5575177adddcd564f">getFoldbyLoop</a> (Eigen::MatrixXd data, vector&lt; char &gt; Label, Eigen::MatrixXd &amp;training, vector&lt; char &gt; &amp;TLabel, Eigen::MatrixXd &amp;test, vector&lt; char &gt; &amp;TtLabel, unsigned int num)</td></tr>
<tr class="memdesc:a74e85088fcdeddd5575177adddcd564f"><td class="mdescLeft">&#160;</td><td class="mdescRight">getFoldbyLoop divide la matrix de datos "data" en dos matrices "tranning" y "test" con los datos pertenecientes a uno de los 5-folds que tenemos de desplazar un 20% al grupo de test sobre el conjunto total. A diferencia de <a class="el" href="mytools_8h.html#a84ae2c8440383fed7b4006741e91cff3" title="getFold divide la matrix de datos &quot;data&quot; en dos matrices &quot;tranning&quot; y &quot;test&quot; con los datos pertenecie...">getFold()</a> intenta utilizar el "for-loop" de las etiquetas para asignar las filas. Sin embargo posee peor rendimiento.  <a href="mytools_8h.html#a74e85088fcdeddd5575177adddcd564f">Más...</a><br /></td></tr>
<tr class="separator:a74e85088fcdeddd5575177adddcd564f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996e2cf1dca6d6f6b2e5004fd6c8f789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mytools_8h.html#a996e2cf1dca6d6f6b2e5004fd6c8f789">getBalancedFold</a> (Eigen::MatrixXd group1, vector&lt; char &gt; label1, Eigen::MatrixXd group2, vector&lt; char &gt; label2, Eigen::MatrixXd &amp;training, vector&lt; char &gt; &amp;TLabel, Eigen::MatrixXd &amp;test, vector&lt; char &gt; &amp;TtLabel, unsigned int num, long int seed)</td></tr>
<tr class="separator:a996e2cf1dca6d6f6b2e5004fd6c8f789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d852399058fecfd4506ac5173a8c2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mytools_8h.html#a29d852399058fecfd4506ac5173a8c2f">shuffleData</a> (MatrixXd &amp;mat, vector&lt; char &gt; &amp;label, long int seed)</td></tr>
<tr class="memdesc:a29d852399058fecfd4506ac5173a8c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">shuffleData utiliza el archivo "random.hpp" y la librería Eigen para crear un vector de índices, al cual barajamos y luego utilizamos ese vector para intercambiar posiciones. Dónde el número que aparezca en la posición 0 es el intercambio de 0 con ese número y así.  <a href="mytools_8h.html#a29d852399058fecfd4506ac5173a8c2f">Más...</a><br /></td></tr>
<tr class="separator:a29d852399058fecfd4506ac5173a8c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef11c31862b1e9d5623ad9611548fd14"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mytools_8h.html#aef11c31862b1e9d5623ad9611548fd14">readValues</a> (string filename, vector&lt; char &gt; &amp;label)</td></tr>
<tr class="memdesc:aef11c31862b1e9d5623ad9611548fd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">readValues es la función utilizada para leer los archivos ".arrf" de la práctia en una Matrix de la libreria "Eigen" y un vector de etiquetas "Label".  <a href="mytools_8h.html#aef11c31862b1e9d5623ad9611548fd14">Más...</a><br /></td></tr>
<tr class="separator:aef11c31862b1e9d5623ad9611548fd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3176dc33dc79b493d699596ece0e1ef7"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mytools_8h.html#a3176dc33dc79b493d699596ece0e1ef7">removeRow</a> (Eigen::MatrixXd matrix, unsigned int rowToRemove)</td></tr>
<tr class="memdesc:a3176dc33dc79b493d699596ece0e1ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">removeRow nos permite quitar una fila de una matrix de entrada (sin modificar la original) y devuelve la matrix resultante modificada.  <a href="mytools_8h.html#a3176dc33dc79b493d699596ece0e1ef7">Más...</a><br /></td></tr>
<tr class="separator:a3176dc33dc79b493d699596ece0e1ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11c0c6f48347a29e1906bf38cb41131"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mytools_8h.html#ab11c0c6f48347a29e1906bf38cb41131">removeCol</a> (Eigen::MatrixXd matrix, unsigned int colToRemove)</td></tr>
<tr class="memdesc:ab11c0c6f48347a29e1906bf38cb41131"><td class="mdescLeft">&#160;</td><td class="mdescRight">removeRow nos permite quitar una columna de una matrix de entrada (sin modificar la original) y devuelve la matrix resultante modificada.  <a href="mytools_8h.html#ab11c0c6f48347a29e1906bf38cb41131">Más...</a><br /></td></tr>
<tr class="separator:ab11c0c6f48347a29e1906bf38cb41131"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descripción detallada</h2>
<div class="textblock"><p >Herramientas definidas para la práctica. </p>
<dl class="section version"><dt>Versión</dt><dd>2.3 </dd></dl>
<dl class="section date"><dt>Fecha</dt><dd>05/04/2022 </dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Brian Sena Simons 3ºA-A2 <div class="fragment"><div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line"> MatrixXd mat(3,2);</div>
<div class="line"> mat &lt;&lt; 1, 1,</div>
<div class="line">        2, 2,</div>
<div class="line">        4, 4;</div>
<div class="line"> </div>
<div class="line"> RowVectorXd fil = <a class="code hl_function" href="mytools_8cpp.html#a3176dc33dc79b493d699596ece0e1ef7">removeRow</a>(mat,2);</div>
<div class="line"> MatriXd::Index pos;</div>
<div class="line"> <span class="keywordtype">double</span> min = <a class="code hl_function" href="mytools_8cpp.html#ad065fd64357444d7792b80876fcfa41f">minEuclideanDistance</a>(fil,mat,pos);</div>
<div class="line"> cout &lt;&lt; <span class="stringliteral">&quot;Mínimo vecino por fila en: &quot;</span> &lt;&lt; pos &lt;&lt; <span class="stringliteral">&quot; con valor: &quot;</span> &lt;&lt; min &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="ttc" id="amytools_8cpp_html_a3176dc33dc79b493d699596ece0e1ef7"><div class="ttname"><a href="mytools_8cpp.html#a3176dc33dc79b493d699596ece0e1ef7">removeRow</a></div><div class="ttdeci">Eigen::MatrixXd removeRow(Eigen::MatrixXd matrix, unsigned int rowToRemove)</div><div class="ttdoc">removeRow nos permite quitar una fila de una matrix de entrada (sin modificar la original) y devuelve...</div><div class="ttdef"><b>Definition:</b> mytools.cpp:323</div></div>
<div class="ttc" id="amytools_8cpp_html_ad065fd64357444d7792b80876fcfa41f"><div class="ttname"><a href="mytools_8cpp.html#ad065fd64357444d7792b80876fcfa41f">minEuclideanDistance</a></div><div class="ttdeci">double minEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data, Eigen::MatrixXd::Index &amp;maxRow)</div><div class="ttdoc">minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila ...</div><div class="ttdef"><b>Definition:</b> mytools.cpp:51</div></div>
</div><!-- fragment --> </dd></dl>
</div><h2 class="groupheader">Documentación de las funciones</h2>
<a id="ad81243b382bfc2358283ab0091c972c3" name="ad81243b382bfc2358283ab0091c972c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81243b382bfc2358283ab0091c972c3">&#9670;&nbsp;</a></span>fillRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fillRange </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>toFill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>upperlimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fillRange rellena un vector de valores desde 0 hasta upperlimit; </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">toFill</td><td>es el vector a rellenar </td></tr>
    <tr><td class="paramname">upperlimit</td><td>es el valor tope del vector</td></tr>
  </table>
  </dd>
</dl>
<p>En esta función hacemos un simple "for-loop" hasta upperlimit dónde en cada iteración asignamos el valor "i" al vector generando una sucesión de 0-upperlimit. </p>

</div>
</div>
<a id="a996e2cf1dca6d6f6b2e5004fd6c8f789" name="a996e2cf1dca6d6f6b2e5004fd6c8f789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996e2cf1dca6d6f6b2e5004fd6c8f789">&#9670;&nbsp;</a></span>getBalancedFold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getBalancedFold </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>group1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt;&#160;</td>
          <td class="paramname"><em>label1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>group2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt;&#160;</td>
          <td class="paramname"><em>label2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>training</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>TLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>TtLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Hace lo mismo que <a class="el" href="mytools_8cpp.html#ac7830bddd694d4aeb550f74ffc23528d" title="getFold divide la matrix de datos &quot;data&quot; en dos matrices &quot;tranning&quot; y &quot;test&quot; con los datos pertenecie...">getFold()</a> pero con un equilibrado de clase de por medio; Se utiliza <a class="el" href="mytools_8cpp.html#abdfd60b2dabf33b1de7720bceaea78dc" title="getClass lo que nos devuelve es una matrix con los datos pertenecientes a una clase específica.">getClass()</a> para obtener matrices correspondente a cada clase, se pasa a este método y lo para cada conjunto utiliza <a class="el" href="mytools_8cpp.html#ac7830bddd694d4aeb550f74ffc23528d" title="getFold divide la matrix de datos &quot;data&quot; en dos matrices &quot;tranning&quot; y &quot;test&quot; con los datos pertenecie...">getFold()</a> para obtener su correspondente 80/20 y luego lo añade todo secuencialmente en el conjunto de entreno y testeo que luego a final son barajados. </p>

</div>
</div>
<a id="a3c2da117b6d8079659b9d6ba6e15fed7" name="a3c2da117b6d8079659b9d6ba6e15fed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2da117b6d8079659b9d6ba6e15fed7">&#9670;&nbsp;</a></span>getClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd getClass </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt;&#160;</td>
          <td class="paramname"><em>Label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getClass lo que nos devuelve es una matrix con los datos pertenecientes a una clase específica. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Matrix de datos completos. </td></tr>
    <tr><td class="paramname">label</td><td>Vector de etiquetas. </td></tr>
    <tr><td class="paramname">type</td><td>Clase específica a buscar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>Matrix con los datos de esa clase</dd></dl>
<p>La idea es iterar sobre el vector de etiquetas y cuando su valor coincida con el especificado por "type" introducimos en la matrix "res" la fila correspondiente para así calcular la matrix con apenas un tipo de clase. </p>

</div>
</div>
<a id="a84ae2c8440383fed7b4006741e91cff3" name="a84ae2c8440383fed7b4006741e91cff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ae2c8440383fed7b4006741e91cff3">&#9670;&nbsp;</a></span>getFold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getFold </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt;&#160;</td>
          <td class="paramname"><em>Label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>training</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>TLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>TtLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getFold divide la matrix de datos "data" en dos matrices "tranning" y "test" con los datos pertenecientes a uno de los 5-folds que tenemos de desplazar un 20% al grupo de test sobre el conjunto total </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Matrix de datos completos. </td></tr>
    <tr><td class="paramname">label</td><td>Vector de etiquetas. </td></tr>
    <tr><td class="paramname">traning</td><td>Matrix con los datos para entrenar. </td></tr>
    <tr><td class="paramname">Tlabel</td><td>Vector con las etiquetas de entreno. </td></tr>
    <tr><td class="paramname">test</td><td>Matrix con los datos para el test. </td></tr>
    <tr><td class="paramname">Ttlabel</td><td>Vector con las etiquetas de test. </td></tr>
    <tr><td class="paramname">num</td><td>Fold a utilizar (0:(0-80%;80%-100%), 1:(0:60%+80%-100%;60%-80%)...)</td></tr>
  </table>
  </dd>
</dl>
<p>La idea es calcular el 20% de la Matrix total y luego con ese valor ir estableciendo el "boundary" superior a copiar para la primera (o toda la parte del dataset de entreno cuando num=0, boundary = 80%) y luego copiar lo que sigue a boundary hasta un 20% más (boundary + size) en test y luego copiar devuelta lo que queda en tranning. Utilizamos la librería de Eigen para un mejor rendimiento. </p>

</div>
</div>
<a id="a74e85088fcdeddd5575177adddcd564f" name="a74e85088fcdeddd5575177adddcd564f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e85088fcdeddd5575177adddcd564f">&#9670;&nbsp;</a></span>getFoldbyLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getFoldbyLoop </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt;&#160;</td>
          <td class="paramname"><em>Label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>training</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>TLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>TtLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getFoldbyLoop divide la matrix de datos "data" en dos matrices "tranning" y "test" con los datos pertenecientes a uno de los 5-folds que tenemos de desplazar un 20% al grupo de test sobre el conjunto total. A diferencia de <a class="el" href="mytools_8h.html#a84ae2c8440383fed7b4006741e91cff3" title="getFold divide la matrix de datos &quot;data&quot; en dos matrices &quot;tranning&quot; y &quot;test&quot; con los datos pertenecie...">getFold()</a> intenta utilizar el "for-loop" de las etiquetas para asignar las filas. Sin embargo posee peor rendimiento. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Matrix de datos completos. </td></tr>
    <tr><td class="paramname">label</td><td>Vector de etiquetas. </td></tr>
    <tr><td class="paramname">traning</td><td>Matrix con los datos para entrenar. </td></tr>
    <tr><td class="paramname">Tlabel</td><td>Vector con las etiquetas de entreno. </td></tr>
    <tr><td class="paramname">test</td><td>Matrix con los datos para el test. </td></tr>
    <tr><td class="paramname">Ttlabel</td><td>Vector con las etiquetas de test. </td></tr>
    <tr><td class="paramname">num</td><td>Fold a utilizar (0:(0-80%;80%-100%), 1:(0:60%+80%-100%;60%-80%)...) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>Ver también</dt><dd><a class="el" href="mytools_8cpp.html#ac7830bddd694d4aeb550f74ffc23528d" title="getFold divide la matrix de datos &quot;data&quot; en dos matrices &quot;tranning&quot; y &quot;test&quot; con los datos pertenecie...">getFold()</a></dd></dl>
<p>La idea es calcular el 20% de la Matrix total y luego con ese valor ir estableciendo el "boundary" superior a copiar para la primera (o toda la parte del dataset de entreno cuando num=0, boundary = 80%) y luego copiar lo que sigue a boundary hasta un 20% más (boundary + size) en test y luego copiar devuelta lo que queda en tranning. Pero en este caso no utilizamos las facilidades de la librería Eigen si no que apenas calculamos el tamaño total de las matrices a rellenar y vamos iterando a la vez que creamos las etiquetas adecuadas. </p>

</div>
</div>
<a id="a4f5825bcc562c6dabe6c136863aedeca" name="a4f5825bcc562c6dabe6c136863aedeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5825bcc562c6dabe6c136863aedeca">&#9670;&nbsp;</a></span>ManualEuclideanDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ManualEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo manualmente. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights</td><td>es el vector de pesos característicos a multiplicar </td></tr>
    <tr><td class="paramname">fixed</td><td>Fila a buscar contenida en data. </td></tr>
    <tr><td class="paramname">data</td><td>Matrix de datos a verificar vecinos. </td></tr>
    <tr><td class="paramname">pos</td><td>Fila de la que provee fixed. </td></tr>
    <tr><td class="paramname">maxRow</td><td>es el ínidice de la fila más cercana encontrada. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>el valor mínimo. </dd></dl>
<dl class="section see"><dt>Ver también</dt><dd><a class="el" href="mytools_8cpp.html#ad065fd64357444d7792b80876fcfa41f" title="minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila ...">minEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,Eigen::MatrixXd::Index &amp;maxRow)</a>;</dd></dl>
<p>Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada "pos". </p><dl class="section see"><dt>Ver también</dt><dd><a class="el" href="mytools_8cpp.html#ad065fd64357444d7792b80876fcfa41f" title="minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila ...">minEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,Eigen::MatrixXd::Index &amp;maxRow)</a> </dd></dl>

</div>
</div>
<a id="aa2fa99f7f091464475f3aa8c1a9f13b5" name="aa2fa99f7f091464475f3aa8c1a9f13b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fa99f7f091464475f3aa8c1a9f13b5">&#9670;&nbsp;</a></span>ManualEuclideanDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ManualEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características manualmente. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights</td><td>es el vector de pesos característicos a multiplicar </td></tr>
    <tr><td class="paramname">fixed</td><td>Fila a buscar contenida en data. </td></tr>
    <tr><td class="paramname">data</td><td>Matrix de datos a verificar vecinos. </td></tr>
    <tr><td class="paramname">pos</td><td>Fila de la que provee fixed. </td></tr>
    <tr><td class="paramname">maxRow</td><td>es el ínidice de la fila más cercana encontrada. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>el valor mínimo. </dd></dl>
<dl class="section see"><dt>Ver también</dt><dd>double <a class="el" href="mytools_8cpp.html#a4f5825bcc562c6dabe6c136863aedeca" title="ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por ...">ManualEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,unsigned int pos,unsigned int &amp;maxRow)</a>;</dd></dl>
<p>Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen ponderado por los pesos característicos calculados y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada "pos". </p><dl class="section see"><dt>Ver también</dt><dd><a class="el" href="mytools_8cpp.html#a4f5825bcc562c6dabe6c136863aedeca" title="ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por ...">ManualEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,unsigned int pos, unsigned int &amp;maxRow)</a>; </dd></dl>

</div>
</div>
<a id="acdf9d105d2e503df5b99f19eddcaca28" name="acdf9d105d2e503df5b99f19eddcaca28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf9d105d2e503df5b99f19eddcaca28">&#9670;&nbsp;</a></span>ManualEuclideanDistanceType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ManualEuclideanDistanceType </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ManualEuclideanDistanceType no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo perteneciente a una clase específica manualmente. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights</td><td>es el vector de pesos característicos a multiplicar </td></tr>
    <tr><td class="paramname">fixed</td><td>Fila a buscar contenida en data. </td></tr>
    <tr><td class="paramname">data</td><td>Matrix de datos a verificar vecinos. </td></tr>
    <tr><td class="paramname">label</td><td>Vector de etiquetas. </td></tr>
    <tr><td class="paramname">type</td><td>Clase a buscar. </td></tr>
    <tr><td class="paramname">pos</td><td>Fila de la que provee fixed. </td></tr>
    <tr><td class="paramname">maxRow</td><td>es el ínidice de la fila más cercana encontrada. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>el valor mínimo. </dd></dl>
<dl class="section see"><dt>Ver también</dt><dd>double <a class="el" href="mytools_8cpp.html#a4f5825bcc562c6dabe6c136863aedeca" title="ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por ...">ManualEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,unsigned int pos,unsigned int &amp;maxRow)</a>;</dd></dl>
<p>Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada "pos" y verificando que sea de tipo "type" con ayuda del vector de etiquetas "label" </p><dl class="section see"><dt>Ver también</dt><dd><a class="el" href="mytools_8cpp.html#a4f5825bcc562c6dabe6c136863aedeca" title="ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por ...">ManualEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,unsigned int pos, unsigned int &amp;maxRow)</a>; </dd></dl>

</div>
</div>
<a id="ac249d23e7dedd767338fd2733fe88c0c" name="ac249d23e7dedd767338fd2733fe88c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac249d23e7dedd767338fd2733fe88c0c">&#9670;&nbsp;</a></span>ManualEuclideanDistanceType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ManualEuclideanDistanceType </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ManualEuclideanDistanceType no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características y perteneciente a una clase específica manualmente. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights</td><td>es el vector de pesos característicos a multiplicar </td></tr>
    <tr><td class="paramname">fixed</td><td>Fila a buscar contenida en data. </td></tr>
    <tr><td class="paramname">data</td><td>Matrix de datos a verificar vecinos. </td></tr>
    <tr><td class="paramname">label</td><td>Vector de etiquetas. </td></tr>
    <tr><td class="paramname">type</td><td>Clase a buscar. </td></tr>
    <tr><td class="paramname">pos</td><td>Fila de la que provee fixed. </td></tr>
    <tr><td class="paramname">maxRow</td><td>es el ínidice de la fila más cercana encontrada. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>el valor mínimo. </dd></dl>
<dl class="section see"><dt>Ver también</dt><dd>double <a class="el" href="mytools_8cpp.html#a15615cc501cd57df609a342fe8cca7c2" title="ManualEuclideanDistanceType no-utiliza completamente la librería Eigen para calcular el menor vecino ...">ManualEuclideanDistanceType(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,vector&lt;char&gt;label, char type, unsigned int pos, unsigned int &amp;maxRow)</a>;</dd></dl>
<p>Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen multiplicado por el vector de características calculado, y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada "pos" y verificando que sea de tipo "type" con ayuda del vector de etiquetas "label" </p><dl class="section see"><dt>Ver también</dt><dd>double <a class="el" href="mytools_8cpp.html#a15615cc501cd57df609a342fe8cca7c2" title="ManualEuclideanDistanceType no-utiliza completamente la librería Eigen para calcular el menor vecino ...">ManualEuclideanDistanceType(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,
     vector&lt;char&gt; label, char type,unsigned int pos, unsigned int &amp;maxRow)</a>; </dd></dl>

</div>
</div>
<a id="ad065fd64357444d7792b80876fcfa41f" name="ad065fd64357444d7792b80876fcfa41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad065fd64357444d7792b80876fcfa41f">&#9670;&nbsp;</a></span>minEuclideanDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double minEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd::Index &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila "fixed" NO contenida en data. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed</td><td>Fila a buscar NO contenida en data. </td></tr>
    <tr><td class="paramname">data</td><td>Matrix de datos a verificar vecinos. </td></tr>
    <tr><td class="paramname">maxRow</td><td>es el ínidice de la fila más cercana encontrada. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>el valor mínimo.</dd></dl>
<p>Usando la librería Eigen sabemos que podemos restarle a una fila un vector de tipe RowVectorXd si activamos el calculo por filas con .rowwise() y además ese resultado podemos concatenarlo en vez de almacenarlo y llamar ahora a .squaredNorm() que calcula la distancia euclidea al cuadrado. Sin embargo, también hemos de decir que la queremos por filas y no por columnas. Luego a continuación hacemos una llamada a minCoeff() que busca el valor mínimo resultante de las operaciones realizadas. </p>

</div>
</div>
<a id="a5d0dd7bbe04f5f18dc592a11c536bb6b" name="a5d0dd7bbe04f5f18dc592a11c536bb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0dd7bbe04f5f18dc592a11c536bb6b">&#9670;&nbsp;</a></span>minEuclideanDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double minEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd::Index &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila "fixed" NO contenida en data multiplicando las distancias por el vector de características que las pondera. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights</td><td>es el vector de pesos característicos a multiplicar </td></tr>
    <tr><td class="paramname">fixed</td><td>Fila a buscar NO contenida en data. </td></tr>
    <tr><td class="paramname">data</td><td>Matrix de datos a verificar vecinos. </td></tr>
    <tr><td class="paramname">maxRow</td><td>es el ínidice de la fila más cercana encontrada. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>el valor mínimo. </dd></dl>
<dl class="section see"><dt>Ver también</dt><dd><a class="el" href="mytools_8cpp.html#ad065fd64357444d7792b80876fcfa41f" title="minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila ...">minEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,Eigen::MatrixXd::Index &amp;maxRow)</a>;</dd></dl>
<p>Hacemos el calculo de la distancia euclidea al cuadrado pero ahora multiplicamos cada parámetro por su respectivo peso que pondera sus características. </p><dl class="section see"><dt>Ver también</dt><dd><a class="el" href="mytools_8cpp.html#ad065fd64357444d7792b80876fcfa41f" title="minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila ...">minEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,Eigen::MatrixXd::Index &amp;maxRow)</a> </dd></dl>

</div>
</div>
<a id="aef11c31862b1e9d5623ad9611548fd14" name="aef11c31862b1e9d5623ad9611548fd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef11c31862b1e9d5623ad9611548fd14">&#9670;&nbsp;</a></span>readValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd readValues </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>readValues es la función utilizada para leer los archivos ".arrf" de la práctia en una Matrix de la libreria "Eigen" y un vector de etiquetas "Label". </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Nombre del archivo que vamos a leer </td></tr>
    <tr><td class="paramname">label</td><td>Vector de etiquetas a rellenar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>Matrix con todos los valores.</dd></dl>
<p>Leemos y utilizamos los "@attribute" del archivo para calcular el tamaño de las columnas de la matrix a rellenar. Luego al leer "@data" lo que haremos es empezar el bucle de rellenado. Dónde en este lo que hacemos es leer un número y una coma, insertar el número en un vector hasta que se alcanze la cantidad de valores calculadas. Luego lo insertamos en la última fila de la matrix y la incrementamos de tamaño para la siguiente iteración. Así hasta que terminemos de leer el archivo. </p>

</div>
</div>
<a id="ab11c0c6f48347a29e1906bf38cb41131" name="ab11c0c6f48347a29e1906bf38cb41131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11c0c6f48347a29e1906bf38cb41131">&#9670;&nbsp;</a></span>removeCol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd removeCol </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>colToRemove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removeRow nos permite quitar una columna de una matrix de entrada (sin modificar la original) y devuelve la matrix resultante modificada. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Matrix con los datos completos. </td></tr>
    <tr><td class="paramname">colToRemove</td><td>Columna a quitar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>Matrix modificada resultante </dd></dl>

</div>
</div>
<a id="a3176dc33dc79b493d699596ece0e1ef7" name="a3176dc33dc79b493d699596ece0e1ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3176dc33dc79b493d699596ece0e1ef7">&#9670;&nbsp;</a></span>removeRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd removeRow </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rowToRemove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removeRow nos permite quitar una fila de una matrix de entrada (sin modificar la original) y devuelve la matrix resultante modificada. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Matrix con los datos completos. </td></tr>
    <tr><td class="paramname">rowToRemove</td><td>Fila a quitar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>Matrix modificada resultante</dd></dl>
<p>La función sobreescribe la fila con la matrix que hay después de esa fila. Y Luego hace un resize para cambiar el tamaño original a una fila menos. </p>

</div>
</div>
<a id="a29d852399058fecfd4506ac5173a8c2f" name="a29d852399058fecfd4506ac5173a8c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d852399058fecfd4506ac5173a8c2f">&#9670;&nbsp;</a></span>shuffleData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void shuffleData </td>
          <td>(</td>
          <td class="paramtype">MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>shuffleData utiliza el archivo "random.hpp" y la librería Eigen para crear un vector de índices, al cual barajamos y luego utilizamos ese vector para intercambiar posiciones. Dónde el número que aparezca en la posición 0 es el intercambio de 0 con ese número y así. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Matrix a permutar filas. @parm label Vector de etiquetas a intercambiar valores. </td></tr>
    <tr><td class="paramname">seed</td><td>Semilla para la función Random</td></tr>
  </table>
  </dd>
</dl>
<p>La idea es un vector de índices a permutar. Dónde el valor de la posición 0 es el índice a permutar con la posición 0. Si vector.at(0) = 2, intercambiamos 0 con el 2. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generado por&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
